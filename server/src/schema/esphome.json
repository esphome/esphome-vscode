{
  "esphome": {
    "schemas": {
      "CONFIG_SCHEMA": {
        "type": "schema",
        "schema": {
          "config_vars": {
            "name": {
              "key": "Required",
              "type": "string",
              "docs": "**string**: This is the name of the node. It should always be unique in your ESPHome network. May only contain lowercase characters, digits and hyphens, and can be at most 24 characters long by default, or 31 characters long if `name_add_mac_suffix` is `false`. See [Changing ESPHome Node Name](https://esphome.io/components/esphome.html#esphome-changing-node-name).\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
            },
            "comment": {
              "key": "Optional",
              "type": "string",
              "docs": "**string**: Additional text information about this node. Only for display in UI.\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
            },
            "build_path": {
              "key": "Required",
              "type": "string",
              "docs": "**string**: Customize where ESPHome will store the build files for your node. By default, ESPHome puts the PlatformIO project it uses to build the firmware in the `.esphome/build/<NODE>` directory, but you can customize this behavior using this option.\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
            },
            "platformio_options": {
              "key": "String",
              "default": "{}",
              "key_type": "string_strict",
              "type": "schema",
              "schema": {
                "config_vars": {
                  "string": {
                    "type": "string"
                  }
                }
              },
              "docs": "**mapping**: Additional options to pass over to PlatformIO in the platformio.ini file. See [platformio_options](https://esphome.io/components/esphome.html#esphome-platformio-options).\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
            },
            "on_boot": {
              "key": "Optional",
              "type": "trigger",
              "schema": {
                "config_vars": {
                  "priority": {
                    "key": "Optional",
                    "default": "600.0",
                    "docs": "**float**: The priority to execute your custom initialization code. A higher value means a high priority and thus also your code being executed earlier. Please note this is an ESPHome-internal value and any change will not be marked as a breaking change. Defaults to `600`. Priorities (you can use any value between them too):\n  * `800.0`: This is where all hardware initialization of vital components is executed. For example setting switches to their initial state.\n  \n  * `600.0`: This is where most sensors are set up.\n  \n  * `250.0`: At this priority, WiFi is initialized.\n  \n  * `200.0`: Network connections like MQTT/native API are set up at this priority.\n  \n  * `-100.0`: At this priority, pretty much everything should already be initialized.\n  \n  \n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#on-boot)*"
                  },
                  "then": {
                    "type": "trigger"
                  }
                }
              },
              "docs": "**[Automation](https://esphome.io/guides/automations.html#automation)**: An automation to perform when the node starts. See [on_boot](https://esphome.io/components/esphome.html#esphome-on-boot).\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
            },
            "on_shutdown": {
              "key": "Optional",
              "type": "trigger",
              "schema": {
                "config_vars": {
                  "priority": {
                    "key": "Optional",
                    "default": "600.0",
                    "docs": "**float**: The priority to execute your custom shutdown code. A higher value means a high priority and in case of shutdown triggers that the code is executed **later**. Priority is used primarily for the initialization order of components. Shutdowns for these components are handled in *reverse* order, such that e.g. sensors (600) are shutdown before the hardware components (800) they depend on. Please note this is an ESPHome-internal value and any change will not be marked as a breaking change. Defaults to `600`. For priority values refer to the list in the [on_boot](https://esphome.io/components/esphome.html#esphome-on-boot) section.\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#on-shutdown)*"
                  },
                  "then": {
                    "type": "trigger"
                  }
                }
              },
              "docs": "**[Automation](https://esphome.io/guides/automations.html#automation)**: An automation to perform right before the node shuts down. See [on_shutdown](https://esphome.io/components/esphome.html#esphome-on-shutdown).\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
            },
            "on_loop": {
              "key": "Optional",
              "type": "trigger",
              "docs": "**[Automation](https://esphome.io/guides/automations.html#automation)**: An automation to perform on each `loop()` iteration. See [on_loop](https://esphome.io/components/esphome.html#esphome-on-loop).\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
            },
            "includes": {
              "key": "Optional",
              "default": "[]",
              "is_list": true,
              "docs": "**list of files**: A list of C/C++ files to include in the main (auto-generated) sketch file for custom components. The paths in this list are relative to the directory where the YAML configuration file is in. See [includes](https://esphome.io/components/esphome.html#esphome-includes).\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
            },
            "libraries": {
              "key": "Optional",
              "default": "[]",
              "is_list": true,
              "type": "string",
              "docs": "**list of libraries**: A list of libraries to include in the project. See [libraries](https://esphome.io/components/esphome.html#esphome-libraries).\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
            },
            "name_add_mac_suffix": {
              "key": "Optional",
              "default": "False",
              "type": "boolean",
              "docs": "**boolean**: Appends the last 3 bytes of the mac address of the device to the name in the form `<name>-aabbcc`. Defaults to `false`. See [Adding the MAC address as a suffix to the device name](https://esphome.io/components/esphome.html#esphome-mac-suffix).\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
            },
            "project": {
              "key": "Optional",
              "type": "schema",
              "schema": {
                "config_vars": {
                  "name": {
                    "key": "Required",
                    "type": "string",
                    "docs": "**string**: Name of the project\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
                  },
                  "version": {
                    "key": "Required",
                    "type": "string",
                    "docs": "**string**: Version of the project\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
                  }
                }
              },
              "docs": "ESPHome Creator\u2019s Project information. See [Project information](https://esphome.io/components/esphome.html#esphome-creators-project).\n  * **name** (**Required**, string): Name of the project\n  \n  * **version** (**Required**, string): Version of the project\n  \n  \n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
            },
            "min_version": {
              "key": "Optional",
              "default": "2022.11.1",
              "docs": "**string**: The minimum ESPHome version required to compile this configuration. See [Minimum ESPHome version](https://esphome.io/components/esphome.html#esphome-min-version).\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
            },
            "compile_process_limit": {
              "key": "Optional",
              "type": "integer",
              "docs": "**int**: The maximum number of simultaneous compile processes to run. Defaults to the number of cores of the CPU which is also the maximum you can set.\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
            }
          }
        }
      }
    }
  },
  "core": {
    "schemas": {
      "time_period_dict": {
        "type": "schema",
        "schema": {
          "config_vars": {
            "days": {
              "key": "Optional"
            },
            "hours": {
              "key": "Optional"
            },
            "minutes": {
              "key": "Optional"
            },
            "seconds": {
              "key": "Optional"
            },
            "milliseconds": {
              "key": "Optional"
            },
            "microseconds": {
              "key": "Optional"
            }
          }
        }
      },
      "positive_time_period_milliseconds": {
        "type": "schema",
        "schema": {
          "extends": [
            "core.time_period_dict"
          ]
        }
      },
      "positive_time_period_seconds": {
        "type": "schema",
        "schema": {
          "extends": [
            "core.time_period_dict"
          ]
        }
      },
      "positive_time_period_minutes": {
        "type": "schema",
        "schema": {
          "extends": [
            "core.time_period_dict"
          ]
        }
      },
      "positive_time_period_microseconds": {
        "type": "schema",
        "schema": {
          "extends": [
            "core.time_period_dict"
          ]
        }
      },
      "MQTT_COMPONENT_SCHEMA": {
        "type": "schema",
        "schema": {
          "config_vars": {
            "retain": {
              "key": "Optional",
              "type": "boolean",
              "docs": "**boolean**: If all MQTT state messages should be retained. Defaults to `true`.\n\n*See also: [MQTT Component Base Configuration](https://esphome.io/components/mqtt.html#mqtt-component-base-configuration)*"
            },
            "discovery": {
              "key": "Optional",
              "type": "boolean",
              "docs": "**boolean**: Manually enable/disable discovery for a component. Defaults to the global default.\n\n*See also: [MQTT Component Base Configuration](https://esphome.io/components/mqtt.html#mqtt-component-base-configuration)*"
            },
            "state_topic": {
              "key": "Optional",
              "docs": "**string**: The topic to publish state updates to. Defaults to `<TOPIC_PREFIX>/<COMPONENT_TYPE>/<COMPONENT_NAME>/state`.\n\n*See also: [MQTT Component Base Configuration](https://esphome.io/components/mqtt.html#mqtt-component-base-configuration)*"
            },
            "availability": {
              "key": "Optional",
              "type": "schema",
              "schema": {
                "config_vars": {
                  "topic": {
                    "key": "Required"
                  },
                  "payload_available": {
                    "key": "Optional",
                    "default": "online"
                  },
                  "payload_not_available": {
                    "key": "Optional",
                    "default": "offline"
                  }
                }
              },
              "docs": "Manually set what should be sent to Home Assistant for showing entity availability. Default derived from [global birth/last will message](https://esphome.io/components/mqtt.html#mqtt-last-will-birth).\n\n*See also: [MQTT Component Base Configuration](https://esphome.io/components/mqtt.html#mqtt-component-base-configuration)*"
            }
          }
        }
      },
      "COMPONENT_SCHEMA": {
        "type": "schema",
        "schema": {
          "config_vars": {
            "setup_priority": {
              "key": "Optional"
            }
          }
        }
      },
      "MQTT_COMMAND_COMPONENT_SCHEMA": {
        "type": "schema",
        "schema": {
          "extends": [
            "core.MQTT_COMPONENT_SCHEMA"
          ],
          "config_vars": {
            "command_topic": {
              "key": "Optional",
              "docs": "**string**: The topic to subscribe to for commands from the remote. Defaults to `<TOPIC_PREFIX>/<COMPONENT_TYPE>/<COMPONENT_NAME>/command`.\n\n*See also: [MQTT Component Base Configuration](https://esphome.io/components/mqtt.html#mqtt-component-base-configuration)*"
            },
            "command_retain": {
              "key": "Optional",
              "type": "boolean",
              "docs": "**boolean**: Whether MQTT command messages sent to the device should be retained or not. Default to `false`.\n\n*See also: [MQTT Component Base Configuration](https://esphome.io/components/mqtt.html#mqtt-component-base-configuration)*"
            },
            "name": {
              "docs": "**string**: The name to use for the MQTT Component.\n\n*See also: [MQTT Component Base Configuration](https://esphome.io/components/mqtt.html#mqtt-component-base-configuration)*"
            }
          }
        }
      },
      "ENTITY_BASE_SCHEMA": {
        "type": "schema",
        "schema": {
          "config_vars": {
            "name": {
              "key": "Optional",
              "type": "string",
              "docs": "**string**: The name for the binary sensor.\n\n*See also: [touchscreen Binary Sensor](https://esphome.io/components/touchscreen/index.html#id1)*"
            },
            "internal": {
              "key": "Optional",
              "type": "boolean",
              "docs": "**boolean**: Mark this component as internal. Internal components will not be exposed to the frontend (like Home Assistant). Only specifying an `id` without a `name` will implicitly set this to true.\n\n*See also: [Text Sensor Component](https://esphome.io/components/text_sensor/index.html#base-text-sensor-configuration)*"
            },
            "disabled_by_default": {
              "key": "Optional",
              "default": "False",
              "type": "boolean",
              "docs": "**boolean**: If true, then this entity should not be added to any client\u2019s frontend, (usually Home Assistant) without the user manually enabling it (via the Home Assistant UI). Requires Home Assistant 2021.9 or newer. Defaults to `false`.\n\n*See also: [Text Sensor Component](https://esphome.io/components/text_sensor/index.html#base-text-sensor-configuration)*"
            },
            "icon": {
              "key": "Optional",
              "docs": "**icon**: Manually set the icon to use for the sensor in the frontend.\n\n*See also: [Text Sensor Component](https://esphome.io/components/text_sensor/index.html#base-text-sensor-configuration)*"
            },
            "entity_category": {
              "key": "Optional",
              "docs": "**string**: The category of the entity. See [https://developers.home-assistant.io/docs/core/entity/#generic-properties](https://developers.home-assistant.io/docs/core/entity/#generic-properties) for a list of available options. Requires Home Assistant 2021.11 or newer. Set to `\"\"` to remove the default entity category.\n\n*See also: [Text Sensor Component](https://esphome.io/components/text_sensor/index.html#base-text-sensor-configuration)*"
            }
          }
        }
      }
    },
    "platforms": {
      "sensor": {
        "docs": "ESPHome has support for many different sensors. Each of them is a platform of the `sensor` domain and each sensor has several base configuration options.\n\n*See also: [Sensor Component](https://esphome.io/components/sensor/index.html#sensor-component)*"
      },
      "binary_sensor": {
        "docs": "With ESPHome you can use different types of binary sensors. They will automatically appear in the Home Assistant front-end and have several configuration options.\n\n*See also: [Binary Sensor Component](https://esphome.io/components/binary_sensor/index.html#binary-sensor-component)*"
      },
      "button": {
        "docs": "To attach a physical button to ESPHome, see [GPIO Binary Sensor](https://esphome.io/components/binary_sensor/gpio.html).\n\n*See also: [Button Component](https://esphome.io/components/button/index.html#button-component)*"
      },
      "canbus": {
        "docs": "Each canbus platform extends this configuration schema.\n\n*See also: [Base CAN Bus Configuration](https://esphome.io/components/canbus.html#base-can-bus-configuration)*"
      },
      "climate": {
        "docs": "ESPHome has support for climate devices. Climate devices can represent different types of hardware, but the defining factor is that climate devices have a settable target temperature and can be put in different modes like HEAT, COOL, HEAT_COOL or OFF.\n\n*See also: [Climate Component](https://esphome.io/components/climate/index.html#climate-component)*"
      },
      "cover": {
        "docs": "The `cover` component is a generic representation of covers in ESPHome. A cover can (currently) either be *closed* or *open* and supports three types of commands: *open*, *close* and *stop*.\n\n*See also: [Cover Component](https://esphome.io/components/cover/index.html#cover-component)*"
      },
      "display": {},
      "fan": {
        "docs": "With the `fan` domain you can create components that appear as fans in the Home Assistant frontend. A fan can be switched on or off, optionally has a speed between 1 and the maximum supported speed of the fan, and can have an oscillation and direction output.\n\n*See also: [Fan Component](https://esphome.io/components/fan/index.html#fan-component)*"
      },
      "light": {
        "docs": "The `light` domain in ESPHome lets you create lights that will automatically be shown in Home Assistant\u2019s frontend and have many features such as RGB colors, transitions, flashing and effects.\n\n*See also: [Light Component](https://esphome.io/components/light/index.html#light-component)*"
      },
      "lock": {
        "docs": "The `lock` domain includes all platforms that should function like a lock with lock/unlock actions.\n\n*See also: [Lock Component](https://esphome.io/components/lock/index.html#lock-component)*"
      },
      "media_player": {
        "docs": "The `media_player` domain includes all platforms that implement media player functionality.\n\n*See also: [Media Player Components](https://esphome.io/components/media_player/index.html#media-player-components)*"
      },
      "number": {
        "docs": "ESPHome has support for components to create a number entity. A number entity is like a sensor that can read a value from a device, but is useful when that value can be set by the user/frontend.\n\n*See also: [Number Component](https://esphome.io/components/number/index.html#number-component)*"
      },
      "output": {
        "docs": "Each output platform extends this configuration schema.\n\n*See also: [Base Output Configuration](https://esphome.io/components/output/index.html#base-output-configuration)*"
      },
      "select": {
        "docs": "ESPHome has support for components to create a select entity. A select entity is basically an option list that can be set by either yaml, hardware or the user/frontend.\n\n*See also: [Select Component](https://esphome.io/components/select/index.html#select-component)*"
      },
      "stepper": {
        "docs": "The `stepper` component allows you to use stepper motors with ESPHome. Currently only the A4988 stepper driver ([datasheet](https://www.pololu.com/file/0J450/a4988_DMOS_microstepping_driver_with_translator.pdf)) and ULN2003 ([datasheet](http://www.ti.com/lit/ds/symlink/uln2003a.pdf)) are supported.\n\n*See also: [Stepper Component](https://esphome.io/components/stepper/index.html#stepper-component)*"
      },
      "switch": {
        "docs": "The `switch` domain includes all platforms that should show up like a switch and can only be turned ON or OFF.\n\n*See also: [Switch Component](https://esphome.io/components/switch/index.html#switch-component)*"
      },
      "text_sensor": {
        "docs": "Text sensors are a lot like normal [sensors](https://esphome.io/components/sensor/index.html). But where the \u201cnormal\u201d sensors only represent sensors that output **numbers**, this component can represent any *text*.\n\n*See also: [Text Sensor Component](https://esphome.io/components/text_sensor/index.html#text-sensor-component)*"
      },
      "time": {
        "docs": "This powerful automation can be used to run automations at specific intervals at specific times of day. The syntax is a subset of the [crontab](https://crontab.guru/) syntax.\n\n*See also: [`on_time` Trigger](https://esphome.io/components/time.html#on-time-trigger)*"
      },
      "touchscreen": {
        "docs": "The `touchscreen` component holds the base code for most touchscreen components available in ESPHome and is responsible for passing the touch events to `binary_sensors` with the `touchscreen` platform.\n\n*See also: [Touchscreen Components](https://esphome.io/components/touchscreen/index.html#touchscreen-components)*"
      }
    },
    "components": {
      "esphome": {
        "docs": "Here you specify some core information that ESPHome needs to create firmwares. Most importantly, this is the section of the configuration where you specify the **name** of the node.\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#esphome-core-configuration)*"
      },
      "adalight": {
        "dependencies": [
          "uart"
        ]
      },
      "adc128s102": {
        "dependencies": [
          "spi"
        ],
        "docs": "The ADC128S102 component allows you to use ADC128S102 8-Channel 12-Bit A/D Converter ([datasheet](https://www.ti.com/lit/ds/symlink/adc128s102.pdf), [Texas Instruments](https://www.ti.com/product/ADC128S102)) in ESPHome. It uses the [SPI Bus](https://esphome.io/components/spi.html#spi) for communication.\n\n*See also: [adc128s102 Component/Hub](https://esphome.io/components/sensor/adc128s102.html#component-hub)*"
      },
      "ads1115": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The `ads1115` domain creates a global hub so that you can later create individual sensors using the [ADS1115 Sensor Platform](https://esphome.io/components/sensor/ads1115.html#id1). To use this hub, first setup the [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) and connect the sensor to the pins specified there.\n\n*See also: [ads1115 Component/Hub](https://esphome.io/components/sensor/ads1115.html#component-hub)*"
      },
      "airthings_ble": {
        "dependencies": [
          "esp32_ble_tracker"
        ]
      },
      "animation": {
        "dependencies": [
          "display"
        ],
        "docs": "Allows to use animated images on displays. Animation inherits all options from the image component. It adds additional lambda methods: `next_frame()`, `prev_frame()` and `set_frame()` to change the shown picture of a gif.\n\n*See also: [Animation](https://esphome.io/components/display/index.html#animation)*"
      },
      "apds9960": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The `apds9960` sensor platform allows you to use your APDS9960 RGB and gesture sensors ([datasheet](https://cdn.sparkfun.com/datasheets/Sensors/Proximity/apds9960.pdf), [SparkFun](https://www.sparkfun.com/products/12787)) with ESPHome. The [I\u00b2C](https://esphome.io/components/i2c.html#i2c) is required to be set up in your configuration for this sensor to work.\n\n*See also: [apds9960 Component/Hub](https://esphome.io/components/sensor/apds9960.html#component-hub)*"
      },
      "api": {
        "dependencies": [
          "network"
        ],
        "docs": "The ESPHome native API is used to communicate with clients directly, with a highly-optimized network protocol. Currently, only the ESPHome tool and Home Assistant use this native API.\n\n*See also: [Native API Component](https://esphome.io/components/api.html#native-api-component)*"
      },
      "as3935_i2c": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The `as3935_i2c` sensor platform allows you to use your AS3935 sensor ([AliExpress](https://de.aliexpress.com/af/as3935.html?SearchText=as3935), [AMS_AS3935](https://ams.com/as3935)) in order to get notified when a thunderstorm is getting close.\n\n*See also: [as3935 Over I\u00b2C](https://esphome.io/components/sensor/as3935.html#over-i2c)*"
      },
      "as3935_spi": {
        "dependencies": [
          "spi"
        ],
        "docs": "The `as3935_spi` sensor platform allows you to use your AS3935 sensor ([AliExpress](https://de.aliexpress.com/af/as3935.html?SearchText=as3935), [AMS_AS3935](https://ams.com/as3935)) in order to get notified when a thunderstorm is getting close.\n\n*See also: [as3935 Over SPI](https://esphome.io/components/sensor/as3935.html#over-spi)*"
      },
      "async_tcp": {},
      "bedjet": {
        "dependencies": [
          "ble_client"
        ],
        "docs": "This component is a global hub that maintains the connection to the BedJet device and delegates status updates to individual platform components.\n\n*See also: [bedjet Component/Hub](https://esphome.io/components/climate/bedjet.html#component-hub)*"
      },
      "ble_client": {
        "dependencies": [
          "esp32_ble_tracker"
        ],
        "docs": "The `ble_client` component enables connections to Bluetooth Low Energy devices in order to query and control them. This component does not expose any sensors or output components itself, but merely manages connections to them for use by other components.\n\n*See also: [BLE Client](https://esphome.io/components/ble_client.html#ble-client)*"
      },
      "bluetooth_proxy": {
        "dependencies": [
          "api",
          "esp32"
        ],
        "docs": "Home Assistant can expand its Bluetooth reach by communicating through the Bluetooth proxy component in ESPHome. Place your ESPHome devices close to the Bluetooth devices that you want to interact with for the best experience.\n\n*See also: [Bluetooth Proxy](https://esphome.io/components/bluetooth_proxy.html#bluetooth-proxy)*"
      },
      "bme680_bsec": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The `bme680_bsec` sensor platform allows you to use your BME680 ([datasheet](https://cdn-shop.adafruit.com/product-files/3660/BME680.pdf), [Adafruit](https://www.adafruit.com/product/3660)) temperature, pressure and humidity and gas sensors with ESPHome via the Bosch Sensortec Environmental Cluster (BSEC) software library. The use of Bosch\u2019s proprietary algorithms provides additional Indoor Air Quality (IAQ), CO2 equivalent and Breath Volatile Organic Compounds (VOC) equivalent measurements.\n\n*See also: [bme680_bsec Component/Hub](https://esphome.io/components/sensor/bme680_bsec.html#component-hub)*"
      },
      "cap1188": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The `cap1188` sensor platform allows you to use your CAP1188 ([datasheet](https://cdn-shop.adafruit.com/datasheets/CAP1188.pdf), [Adafruit](https://learn.adafruit.com/adafruit-cap1188-breakout/overview)) Capacitive Touch Sensor with ESPHome. The [I\u00b2C](https://esphome.io/components/i2c.html#i2c) bus is required to be set up in your configuration for this sensor to work.\n\n*See also: [cap1188 Component/Hub](https://esphome.io/components/binary_sensor/cap1188.html#component-hub)*"
      },
      "captive_portal": {
        "dependencies": [
          "wifi"
        ],
        "docs": "The captive portal component in ESPHome is a fallback mechanism for when connecting to the configured [WiFi](https://esphome.io/components/wifi.html) fails.\n\n*See also: [Captive Portal](https://esphome.io/components/captive_portal.html#captive-portal)*"
      },
      "cd74hc4067": {
        "docs": "**[Pin](https://esphome.io/guides/configuration-types.html#config-pin)**: The I/O pins connected to the S0 to S3 channel selection pins\n\n*See also: [cd74hc4067 Component/Hub](https://esphome.io/components/sensor/cd74hc4067.html#component-hub)*"
      },
      "color": {
        "docs": "When using RGB-capable displays in ESPHome you may wish to use custom colors. A `color` component exists for just this purpose:\n\n*See also: [Color](https://esphome.io/components/display/index.html#color)*"
      },
      "custom_component": {
        "docs": "This integration can be used to create generic custom components in ESPHome using the C++ (Arduino) API. This integration should be used in cases where none of ESPHome\u2019s abstraction layers (for example the \u201csensor\u201d, \u201cbinary sensor\u201d, \u201cswitch\u201d, etc concepts) work well for your integration.\n\n*See also: [Generic Custom Component](https://esphome.io/custom/custom_component.html#generic-custom-component)*"
      },
      "dac7678": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The DAC7678 component represents a DAC7678 12-bit 8 channel DAC with internal reference ([datasheet](https://www.ti.com/lit/ds/symlink/dac7678.pdf)) in ESPHome. It uses the [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) for communication.\n\n*See also: [dac7678 Component/Hub](https://esphome.io/components/output/dac7678.html#component-hub)*"
      },
      "dallas": {
        "docs": "The `dallas` component allows you to use your [DS18b20](https://www.adafruit.com/product/374) ([datasheet](https://datasheets.maximintegrated.com/en/ds/DS18B20.pdf)) and similar 1-Wire temperature sensors.\n\n*See also: [dallas Component/Hub](https://esphome.io/components/sensor/dallas.html#component-hub)*"
      },
      "daly_bms": {
        "dependencies": [
          "uart"
        ],
        "docs": "**[Time](https://esphome.io/guides/configuration-types.html#config-time)**: Delay between data requests.\n\n*See also: [daly_bms Component/Hub](https://esphome.io/components/sensor/daly_bms.html#component-hub)*"
      },
      "dashboard_import": {
        "dependencies": [
          "api"
        ]
      },
      "debug": {
        "dependencies": [
          "logger"
        ],
        "docs": "The `debug` component can be used to debug problems with ESPHome. At startup, it prints a bunch of useful information like reset reason, free heap size, ESPHome version and so on. It also allows you get the same information as a text sensor, and to monitor the state of the ESP heap memory (free space, maximum free block size and fragmentation level) and the main-loop timing.\n\n*See also: [Debug Component](https://esphome.io/components/debug.html#debug-component)*"
      },
      "deep_sleep": {
        "docs": "The `deep_sleep` component can be used to automatically enter a deep sleep mode on the ESP8266/ESP32 after a certain amount of time. This is especially useful with nodes that operate on batteries and therefore need to conserve as much energy as possible.\n\n*See also: [Deep Sleep Component](https://esphome.io/components/deep_sleep.html#deep-sleep-component)*"
      },
      "demo": {
        "docs": "The `demo` integration can be used for testing to generate sample instances of many different integrations (sensors, lights, \u2026)\n\n*See also: [Demo Integration](https://esphome.io/components/demo.html#demo-integration)*"
      },
      "dfplayer": {
        "dependencies": [
          "uart"
        ],
        "docs": "The `dfplayer` ([datasheet](https://wiki.dfrobot.com/DFPlayer_Mini_SKU_DFR0299)), component allows you to play sound and music stored in an SD card or USB flash drive.\n\n*See also: [DF-Player mini](https://esphome.io/components/dfplayer.html#df-player-mini)*"
      },
      "dsmr": {
        "dependencies": [
          "uart"
        ],
        "docs": "The DSMR component connects to Dutch Smart Meters which comply to DSMR (Dutch Smart Meter Requirements), also known as \u2018Slimme meter\u2019 or \u2018P1 port\u2019.\n\n*See also: [dsmr Component/Hub](https://esphome.io/components/sensor/dsmr.html#component-hub)*"
      },
      "e131": {
        "dependencies": [
          "network"
        ],
        "docs": "The [E1.31 Effect](https://esphome.io/components/light/index.html#e131-light-effect) requires a component hub for the `e131` light effect.\n\n*See also: [E1.31 Component](https://esphome.io/components/light/index.html#e1-31-component)*"
      },
      "esp32": {
        "docs": "This is an alternative base framework for ESP32 chips, and recommended for variants of the ESP32 like ESP32S2, ESP32S3, ESP32C3 and single-core ESP32 chips.\n\n*See also: [ESP-IDF framework](https://esphome.io/components/esp32.html#esp-idf-framework)*"
      },
      "esp32_ble": {
        "dependencies": [
          "esp32"
        ],
        "docs": "The `esp32_ble` component in ESPHome sets up the Bluetooth LE stack on the device so that a [BLE Server](https://esphome.io/components/esp32_ble_server.html) can run.\n\n*See also: [BLE Component](https://esphome.io/components/esp32_ble.html#ble-component)*"
      },
      "esp32_ble_beacon": {
        "dependencies": [
          "esp32"
        ],
        "docs": "The `esp32_ble_beacon` component creates a Bluetooth Low Energy Beacon with your ESP32 device. Beacons are BLE devices that repeatedly just send out a pre-defined packet of data. This packet can then be received by devices like smartphones and can then be used to track a phone\u2019s location.\n\n*See also: [ESP32 Bluetooth Low Energy Beacon](https://esphome.io/components/esp32_ble_beacon.html#esp32-bluetooth-low-energy-beacon)*"
      },
      "esp32_ble_server": {
        "dependencies": [
          "esp32"
        ],
        "docs": "The `esp32_ble_server` component in ESPHome sets up a simple BLE GATT server that exposes the device name, manufacturer and board. This component allows other components to create their own services to expose data and control.\n\n*See also: [BLE Server](https://esphome.io/components/esp32_ble_server.html#ble-server)*"
      },
      "esp32_ble_tracker": {
        "dependencies": [
          "esp32"
        ],
        "docs": "The `esp32_ble_tracker` component creates a global hub so that you can track bluetooth low energy devices using your ESP32 node.\n\n*See also: [ESP32 Bluetooth Low Energy Tracker Hub](https://esphome.io/components/esp32_ble_tracker.html#esp32-bluetooth-low-energy-tracker-hub)*"
      },
      "esp32_camera": {
        "dependencies": [
          "esp32"
        ],
        "docs": "The `esp32_camera` component allows you to use ESP32-based camera boards in ESPHome that directly integrate into Home Assistant through the native API.\n\n*See also: [ESP32 Camera Component](https://esphome.io/components/esp32_camera.html#esp32-camera-component)*"
      },
      "esp32_camera_web_server": {
        "dependencies": [
          "esp32_camera"
        ],
        "docs": "The `esp32_camera_web_server` component allows you to use expose web server of ESP32-based camera boards in ESPHome that directly can be integrated into external surveillance or PVR software.\n\n*See also: [ESP32 Camera Web Server Component](https://esphome.io/components/esp32_camera_web_server.html#esp32-camera-web-server-component)*"
      },
      "esp32_improv": {
        "dependencies": [
          "wifi",
          "esp32"
        ],
        "docs": "The `esp32_improv` component in ESPHome implements the open [Improv standard](https://www.improv-wifi.com/) for configuring Wi-Fi on an ESP32 device by using Bluetooth Low Energy to receive the credentials.\n\n*See also: [Improv via BLE](https://esphome.io/components/esp32_improv.html#improv-via-ble)*"
      },
      "esp32_touch": {
        "dependencies": [
          "esp32"
        ],
        "docs": "The `esp32_touch` component creates a global hub for detecting touches on the eight touch pads of the ESP32 as [binary sensors](https://esphome.io/components/binary_sensor/esp32_touch.html#esp32-touch-binary-sensor).\n\n*See also: [esp32_touch Component/Hub](https://esphome.io/components/binary_sensor/esp32_touch.html#component-hub)*"
      },
      "esp8266": {
        "docs": "This component contains platform-specific options for the ESP8266 platform.\n\n*See also: [ESP8266 Platform](https://esphome.io/components/esp8266.html#esp8266-platform)*"
      },
      "ethernet": {
        "dependencies": [
          "esp32"
        ],
        "docs": "This ESPHome component enables *wired* Ethernet connections for ESP32s.\n\n*See also: [Ethernet Component](https://esphome.io/components/ethernet.html#ethernet-component)*"
      },
      "exposure_notifications": {
        "dependencies": [
          "esp32_ble_tracker"
        ],
        "docs": "The `exposure_notifications` component uses the [ESP32 Bluetooth Low Energy Tracker Hub](https://esphome.io/components/esp32_ble_tracker.html) to discover nearby COVID-19 exposure notification bluetooth messages sent by phones running the [Google/Apple Exposure Notification service](https://www.google.com/covid19/exposurenotifications/).\n\n*See also: [Exposure Notification Listener](https://esphome.io/components/exposure_notifications.html#exposure-notification-listener)*"
      },
      "external_components": {
        "docs": "You can easily import community or personal components using the external components feature. Bundled components can be overridden using this feature.\n\n*See also: [External Components](https://esphome.io/components/external_components.html#external-components)*"
      },
      "ezo_pmp": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The `ezo_pmp` component allows you to use an Atlas Scientific Peristaltic Pump with ESPHome. Both the EZO-PMP ([datasheet](https://files.atlas-scientific.com/EZO_PMP_Datasheet.pdf)) and EZO-PMP-L ([datasheet](https://files.atlas-scientific.com/EZO_PMP_L_Datasheet.pdf)) are supported. The [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) is required to be set up in your configuration for this sensor to work.\n\n*See also: [Atlas Scientific Peristaltic Pump](https://esphome.io/components/ezo_pmp.html#atlas-scientific-peristaltic-pump)*"
      },
      "fingerprint_grow": {
        "dependencies": [
          "uart"
        ],
        "docs": "The reader can be powered by the 3.3V output of an NodeMCU. As the communication with the reader is done using UART (default baud rate is 57600), you need to have an [UART bus](https://esphome.io/components/uart.html#uart) in your configuration with the `rx_pin` connected to the reader\u2019s `TX` and the `tx_pin` connected to the reader\u2019s `RX`.\n\n*See also: [fingerprint_grow Component/Hub](https://esphome.io/components/fingerprint_grow.html#component-hub)*"
      },
      "font": {
        "dependencies": [
          "display"
        ],
        "docs": "The rendering engine also has a powerful font drawer which integrates seamlessly into ESPHome. Whereas in most Arduino display projects you have to use one of a few pre-defined fonts in very specific sizes, with ESPHome you have the option to use **any** TrueType (`.ttf`) font file at **any** size, as well as fixed-size [PCF](https://en.wikipedia.org/wiki/Portable_Compiled_Format) and [BDF](https://en.wikipedia.org/wiki/Glyph_Bitmap_Distribution_Format) bitmap fonts! Granted the reason for it is actually not having to worry about the licensing of font files :)\n\n*See also: [Fonts](https://esphome.io/components/display/index.html#fonts)*"
      },
      "globals": {
        "docs": "In some cases you might require to share a global variable across multiple lambdas. For example, global variables can be used to store the state of a garage door.\n\n*See also: [Global Variables](https://esphome.io/guides/automations.html#global-variables)*"
      },
      "gps": {
        "dependencies": [
          "uart"
        ],
        "docs": "The `gps` component allows you to connect GPS modules to your ESPHome project. Any GPS module that uses the standardized NMEA communication protocol will work.\n\n*See also: [GPS Component](https://esphome.io/components/gps.html#gps-component)*"
      },
      "graph": {
        "dependencies": [
          "display",
          "sensor"
        ],
        "docs": "You can display a graph of a sensor value(s) using this component. The states used for the graph are stored in memory at the time the sensor updates and will be lost when the device reboots.\n\n*See also: [Graph Component](https://esphome.io/components/display/index.html#graph-component)*"
      },
      "http_request": {
        "dependencies": [
          "network"
        ],
        "docs": "The `http_request` component lets you make HTTP/HTTPS requests. First, you need to setup a component:\n\n*See also: [HTTP Request](https://esphome.io/components/http_request.html#http-request)*"
      },
      "i2c": {
        "docs": "This component sets up the I\u00b2C bus for your ESP32 or ESP8266. In order for these components to work correctly, you need to define the I\u00b2C bus in your configuration. Please note the ESP will enable its internal 10k\u2126 pullup resistors for these pins, so you usually don\u2019t need to put on external ones. You can use multiple devices on one I\u00b2C bus as each device is given a unique address for communicating between it and the ESP. You can do this by hopping wires from the two lines (SDA and SCL) from each device board to the next device board or by connecting the wires from each device back to the two I\u00b2C pins on the ESP.\n\n*See also: [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c-bus)*"
      },
      "image": {
        "dependencies": [
          "display"
        ],
        "docs": "Use this component to store graphical images on the device, you can then draw the images on compatible displays.\n\n*See also: [Images](https://esphome.io/components/display/index.html#images)*"
      },
      "improv_serial": {
        "dependencies": [
          "logger",
          "wifi"
        ],
        "docs": "The `improv_serial` component in ESPHome implements the open [Improv standard](https://www.improv-wifi.com/) for configuring Wi-Fi on an ESPHome device by using a serial connection to the device, eg. USB.\n\n*See also: [Improv via Serial](https://esphome.io/components/improv_serial.html#improv-via-serial)*"
      },
      "interval": {
        "docs": "This component allows you to run actions at fixed time intervals. For example if you want to toggle a switch every minute, you can use this component. Please note that it\u2019s possible to achieve the same thing with the [time.on_time](https://esphome.io/components/time.html#time-on-time) trigger, but this technique is more light-weight and user-friendly.\n\n*See also: [interval Component](https://esphome.io/guides/automations.html#interval-component)*"
      },
      "json": {},
      "lcd_menu": {
        "docs": "The component provides an infrastructure for setting up a hierarchical menu on the character based LCD displays.\n\n*See also: [LCD Menu](https://esphome.io/components/display_menu/lcd_menu.html#lcd-menu)*"
      },
      "logger": {
        "docs": "The logger component automatically logs all log messages through the serial port and through MQTT topics (if there is an MQTT client in the configuration). By default, all logs with a severity higher than `DEBUG` will be shown. Decreasing the log level can help with the performance of the application and memory size.\n\n*See also: [Logger Component](https://esphome.io/components/logger.html#logger-component)*"
      },
      "mcp23008": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The MCP23008 component ([datasheet](http://ww1.microchip.com/downloads/en/devicedoc/21919e.pdf), [Adafruit](https://www.adafruit.com/product/593)) has 8 GPIOs that can be configured independently.\n\n*See also: [MCP23008 Component](https://esphome.io/components/mcp230xx.html#mcp23008-component)*"
      },
      "mcp23016": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The MCP23016 component ([datasheet](http://ww1.microchip.com/downloads/en/devicedoc/20090c.pdf)) has 16 GPIOs and can be configured the same way than the other variants.\n\n*See also: [MCP23016 Component](https://esphome.io/components/mcp230xx.html#mcp23016-component)*"
      },
      "mcp23017": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The MCP23017 component allows you to use MCP23017 I/O expanders ([datasheet](http://ww1.microchip.com/downloads/en/devicedoc/20001952c.pdf), [Adafruit](https://www.adafruit.com/product/732)) in ESPHome. It uses the [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) for communication.\n\n*See also: [MCP23017 Component](https://esphome.io/components/mcp230xx.html#mcp23017-component)*"
      },
      "mcp23s08": {
        "dependencies": [
          "spi"
        ],
        "docs": "The MCP23S08 component ([datasheet](http://ww1.microchip.com/downloads/en/DeviceDoc/MCP23008-MCP23S08-Data-Sheet-20001919F.pdf), [Digi-Key](https://www.digikey.com/product-detail/en/microchip-technology/MCP23S08-E-P/MCP23S08-E-P-ND/735954)) has 8 GPIOs that can be configured independently.\n\n*See also: [MCP23S08 Component](https://esphome.io/components/mcp23Sxx.html#mcp23s08-component)*"
      },
      "mcp23s17": {
        "dependencies": [
          "spi"
        ],
        "docs": "The MCP23S17 component allows you to use MCP23S17 I/O expanders ([datasheet](http://ww1.microchip.com/downloads/en/DeviceDoc/20001952C.pdf), [Digi-Key](https://www.digikey.com/product-detail/en/microchip-technology/MCP23S17-E-SP/MCP23S17-E-SP-ND/894276)) in ESPHome. It uses the [SPI Bus](https://esphome.io/components/spi.html#spi) for communication.\n\n*See also: [MCP23S17 Component](https://esphome.io/components/mcp23Sxx.html#mcp23s17-component)*"
      },
      "mcp3008": {
        "dependencies": [
          "spi"
        ],
        "docs": "The MCP3008 component allows you to use MCP3008 8-Channel 10-Bit A/D Converter ([datasheet](http://ww1.microchip.com/downloads/en/DeviceDoc/21295d.pdf), [Adafruit](https://www.adafruit.com/product/856)) in ESPHome. It uses the [SPI Bus](https://esphome.io/components/spi.html#spi) for communication.\n\n*See also: [mcp3008 Component/Hub](https://esphome.io/components/sensor/mcp3008.html#component-hub)*"
      },
      "mcp3204": {
        "dependencies": [
          "spi"
        ],
        "docs": "The MCP3204 component allows you to use MCP3204 or MCP3208 12-Bit A/D Converter ([datasheet](https://ww1.microchip.com/downloads/en/DeviceDoc/21298e.pdf)) in ESPHome. The MCP3204 is a 4-channel and MCP3208 is an 8-channel device. It uses the [SPI Bus](https://esphome.io/components/spi.html#spi) for communication.\n\n*See also: [mcp3204 Component/Hub](https://esphome.io/components/sensor/mcp3204.html#component-hub)*"
      },
      "mcp4728": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The MCP4728 output component allows to use [12bit external quad DAC](https://www.adafruit.com/product/4470) in order to have analog outputs on any board by using [I\u00b2C](https://esphome.io/components/i2c.html#i2c). Devices default address is `0x60`.\n\n*See also: [MCP4728 Component](https://esphome.io/components/output/mcp4728.html#mcp4728-component)*"
      },
      "mdns": {
        "dependencies": [
          "network"
        ],
        "docs": "The `mdns` component makes the node announce itself on the local network using the multicast DNS (mDNS) protocol.\n\n*See also: [mDNS Component](https://esphome.io/components/mdns.html#mdns-component)*"
      },
      "modbus": {
        "dependencies": [
          "uart"
        ],
        "docs": "The Modbus protocol is used by many consumer and industrial devices for communication. This component allows components in ESPHome to communicate to those devices. Modbus requires a [UART Bus](https://esphome.io/components/uart.html#uart) to communicate.\n\n*See also: [Modbus Component](https://esphome.io/components/modbus.html#modbus-component)*"
      },
      "modbus_controller": {
        "docs": "The `modbus_controller` component creates a RS485 connection to control a modbus device\n\n*See also: [Modbus Controller](https://esphome.io/components/modbus_controller.html#modbus-controller)*"
      },
      "mopeka_ble": {
        "dependencies": [
          "esp32_ble_tracker"
        ]
      },
      "mpr121": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The `mpr121` sensor platform allows you to use your MPR121 ([datasheet](https://cdn-learn.adafruit.com/downloads/pdf/adafruit-mpr121-12-key-capacitive-touch-sensor-breakout-tutorial.pdf), [Adafruit](https://learn.adafruit.com/adafruit-mpr121-12-key-capacitive-touch-sensor-breakout-tutorial/overview)) Capacitive Touch Sensor with ESPHome. The [I\u00b2C](https://esphome.io/components/i2c.html#i2c) is required to be set up in your configuration for this sensor to work.\n\n*See also: [mpr121 Component/Hub](https://esphome.io/components/binary_sensor/mpr121.html#component-hub)*"
      },
      "mqtt": {
        "dependencies": [
          "network"
        ],
        "docs": "With the MQTT Message schema you can tell ESPHome how a specific MQTT message should be sent. It is used in several places like last will and birth messages or MQTT log options.\n\n*See also: [MQTTMessage](https://esphome.io/components/mqtt.html#mqttmessage)*"
      },
      "my9231": {
        "docs": "The MY9231/MY9291 component represents a MY9231/MY9291 LED diver chain ([MY9231 description](http://www.my-semi.com.tw/file/MY9231_BF_0.91.pdf), [MY9291 description](http://www.my-semi.com.tw/file/MY9291_BF_0.91.pdf)) in ESPHome. Communication is done with two GPIO pins (DI and DCKI) and multiple driver chips can be chained. There are two models with different number of output channels (MY9291 with 4 channels and MY9231 with 3 channels). They are popular driver chips used in smart light bulbs:\n\n*See also: [my9231 Component/Hub](https://esphome.io/components/output/my9231.html#component-hub)*"
      },
      "network": {
        "docs": "The network component is a global configuration for all types of networks (WiFi, Ethernet).\n\n*See also: [Network component](https://esphome.io/components/network.html#network-component)*"
      },
      "ota": {
        "dependencies": [
          "network"
        ],
        "docs": "With the OTA (Over The Air) update component you can upload your firmware binaries to your node without having to use a USB cable for uploads. ESPHome natively supports this through its `run` and `upload` helper scripts.\n\n*See also: [OTA Update Component](https://esphome.io/components/ota.html#ota-update-component)*"
      },
      "packages": {},
      "pca9685": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The PCA9685 component represents a PCA9685 12-bit PWM driver ([datasheet](https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/peripherals/ledc.html#configure-channel), [adafruit](https://www.adafruit.com/product/815)) in ESPHome. It uses [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) for communication.\n\n*See also: [pca9685 Component/Hub](https://esphome.io/components/output/pca9685.html#component-hub)*"
      },
      "pcf8574": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The PCF8574 component allows you to use PCF8574 or PCF8575 I/O expanders ([datasheet](http://www.ti.com/lit/ds/symlink/pcf8574.pdf), [SparkFun](https://www.sparkfun.com/products/retired/8130)) in ESPHome. It uses [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) for communication.\n\n*See also: [PCF8574 I/O Expander](https://esphome.io/components/pcf8574.html#pcf8574-i-o-expander)*"
      },
      "pipsolar": {
        "dependencies": [
          "uart"
        ],
        "docs": "The PipSolar component allows you to integrate PIP-compatible Inverters in ESPHome. It uses [UART](https://esphome.io/components/uart.html#uart) for communication.\n\n*See also: [PipSolar PV Inverter](https://esphome.io/components/pipsolar.html#pipsolar-pv-inverter)*"
      },
      "pn532": {},
      "pn532_i2c": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The `pn532` component allows you to use PN532 NFC/RFID controllers ([datasheet](https://cdn-shop.adafruit.com/datasheets/pn532ds.pdf), [Adafruit](https://www.adafruit.com/product/364)) with ESPHome. This component is a global hub that establishes the connection to the PN532 via [I\u00b2C](https://esphome.io/components/i2c.html#i2c) and outputs its data. Using the [PN532 binary sensors](https://esphome.io/components/binary_sensor/pn532.html#pn532-tag) you can then create individual binary sensors that track if an NFC/RFID tag is currently detected by the PN532.\n\n*See also: [pn532 Over I\u00b2C](https://esphome.io/components/binary_sensor/pn532.html#over-i2c)*"
      },
      "pn532_spi": {
        "dependencies": [
          "spi"
        ],
        "docs": "The `pn532_spi` component allows you to use PN532 NFC/RFID controllers ([datasheet](https://cdn-shop.adafruit.com/datasheets/pn532ds.pdf), [Adafruit](https://www.adafruit.com/product/364)) with ESPHome. This component is a global hub that establishes the connection to the PN532 via [SPI](https://esphome.io/components/spi.html#spi) and outputs its data. Using the [PN532 binary sensors](https://esphome.io/components/binary_sensor/pn532.html#pn532-tag) you can then create individual binary sensors that track if an NFC/RFID tag is currently detected by the PN532.\n\n*See also: [pn532 Over SPI](https://esphome.io/components/binary_sensor/pn532.html#over-spi)*"
      },
      "power_supply": {
        "docs": "The `power_supply` component allows you to have a high power mode for certain outputs. For example, if you\u2019re using an [ATX power supply](https://en.wikipedia.org/wiki/ATX) to power your LED strips, you usually don\u2019t want to have the power supply on all the time while the output is not on. The power supply component can be attached to any [Output Component](https://esphome.io/components/output/index.html#output) and will automatically switch on if any of the outputs are on. Furthermore, it also has a cooldown time that keeps the power supply on for a while after the last output has been disabled.\n\n*See also: [Power Supply Component](https://esphome.io/components/power_supply.html#power-supply-component)*"
      },
      "preferences": {},
      "prometheus": {
        "docs": "The `prometheus` component enables an HTTP endpoint for the [Web Server Component](https://esphome.io/components/web_server.html) in order to integrate a [Prometheus](https://prometheus.io/) installation.\n\n*See also: [Prometheus Component](https://esphome.io/components/prometheus.html#prometheus-component)*"
      },
      "psram": {},
      "qr_code": {
        "dependencies": [
          "display"
        ],
        "docs": "Use this component to generate a QR-code containing a string on the device, which can then be drawn on compatible displays.\n\n*See also: [QR Code Component](https://esphome.io/components/display/index.html#qr-code-component)*"
      },
      "radon_eye_ble": {
        "dependencies": [
          "esp32_ble_tracker"
        ]
      },
      "rc522_i2c": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The `rc522_i2c` component allows you to use RC522 RFID controllers with ESPHome. This component is a global hub that establishes the connection to the RC522 via [I\u00b2C](https://esphome.io/components/i2c.html#i2c) (also available over SPI). Using the [RC522 binary sensors](https://esphome.io/components/binary_sensor/rc522.html#rc522-tag) you can then create individual binary sensors that track if an RFID tag is currently detected by the RC522.\n\n*See also: [rc522 Over I\u00b2C](https://esphome.io/components/binary_sensor/rc522.html#over-i2c)*"
      },
      "rc522_spi": {
        "dependencies": [
          "spi"
        ],
        "docs": "The `rc522_spi` component allows you to use RC522 RFID controllers with ESPHome. This component is a global hub that establishes the connection to the RC522 via [SPI](https://esphome.io/components/spi.html#spi) (also available over I\u00b2C). Using the [RC522 binary sensors](https://esphome.io/components/binary_sensor/rc522.html#rc522-tag) you can then create individual binary sensors that track if an RFID tag is currently detected by the RC522.\n\n*See also: [rc522 Over SPI](https://esphome.io/components/binary_sensor/rc522.html#over-spi)*"
      },
      "rdm6300": {
        "dependencies": [
          "uart"
        ],
        "docs": "The `rdm6300` component allows you to use RDM6300 NFC/RFID controllers ([datasheet](https://elty.pl/upload/download/RFID/RDM630-Spec.pdf), [iTead](https://www.itead.cc/rdm6300.html)) with ESPHome. This component is a global hub that establishes the connection to the RDM6300 via [UART](https://esphome.io/components/uart.html#uart) and translates the received data. Using the [RDM6300 binary sensors](https://esphome.io/components/binary_sensor/rdm6300.html#rdm6300-tag) you can then create individual binary sensors that track if an NFC/RFID tag is currently detected by the RDM6300.\n\n*See also: [rdm6300 Component/Hub](https://esphome.io/components/binary_sensor/rdm6300.html#component-hub)*"
      },
      "remote_receiver": {
        "docs": "The `remote_receiver` component lets you receive and decode any remote signal, these can for example be infrared remotes or 433MHz signals.\n\n*See also: [Remote Receiver](https://esphome.io/components/remote_receiver.html#remote-receiver)*"
      },
      "remote_transmitter": {
        "docs": "The `remote_transmitter` component lets you send digital packets to control devices in your home. For example this includes infrared data or 433MHz RF signals.\n\n*See also: [Remote Transmitter](https://esphome.io/components/remote_transmitter.html#remote-transmitter)*"
      },
      "rf_bridge": {
        "dependencies": [
          "uart"
        ],
        "docs": "The `RF Bridge` Component provides the ability to send and receive 433MHz remote codes without hardware hacking the circuit board to bypass the `efm8bb1` MCU. This component implements the communication protocol that the original `efm8bb1` firmware implements. The device is connected via the [UART bus](https://esphome.io/components/uart.html). The uart bus must be configured at the same speed of the module which is 19200bps.\n\n*See also: [RF Bridge Component](https://esphome.io/components/rf_bridge.html#rf-bridge-component)*"
      },
      "rp2040": {
        "docs": "This component contains platform-specific options for the RP2040 platform.\n\n*See also: [RP2040 Platform](https://esphome.io/components/rp2040.html#rp2040-platform)*"
      },
      "rtttl": {
        "docs": "The `rtttl`, component allows you to easily connect a passive piezo buzzer to your microcontroller and play monophonic songs. It accepts the Ring Tone Text Transfer Language, rtttl format ([Wikipedia](https://en.wikipedia.org/wiki/Ring_Tone_Transfer_Language)) which allows to store simple melodies.\n\n*See also: [Rtttl Buzzer](https://esphome.io/components/rtttl.html#rtttl-buzzer)*"
      },
      "ruuvi_ble": {
        "dependencies": [
          "esp32_ble_tracker"
        ]
      },
      "script": {
        "docs": "With the `script:` component you can define a list of steps in a central place, and then execute the script with a single call.\n\n*See also: [script Component](https://esphome.io/guides/automations.html#script-component)*"
      },
      "servo": {
        "docs": "The `servo` component allows you to use servo motors with ESPHome. Servos are motor controllers that contain all the electronics necessary for driving the motor and provide a simple PWM interface to control the motor.\n\n*See also: [Servo Component](https://esphome.io/components/servo.html#servo-component)*"
      },
      "sim800l": {
        "dependencies": [
          "uart"
        ],
        "docs": "The `SIM800L` Component provides the ability to dial, answer calls, send/receive SMS text messages and send/receive USSD codes. The device must be connected via a [UART bus](https://esphome.io/components/uart.html) supporting both receiving and transmitting line. The UART bus must be configured at the same speed of the module which is by default 9600bps. The required connection wires are `+VCC`, `GND`, `RX` and `TX`.\n\n*See also: [sim800l Component/Hub](https://esphome.io/components/sim800l.html#component-hub)*"
      },
      "sm16716": {
        "docs": "The SM16716 component represents a SM16716 LED diver chain ([SM16716 description](https://github.com/sowbug/sm16716/blob/master/SM16716%20Datasheet%20%5BChinese%5D.pdf), [SM16716 description](https://github.com/sowbug/sm16716/blob/master/SM16716%20Datasheet%20%5BChinese%5D.pdf)) in ESPHome. Communication is done with two GPIO pins (MOSI and SCLK) and multiple driver chips can be chained. It is used in some smart light bulbs:\n\n*See also: [sm16716 Component/Hub](https://esphome.io/components/output/sm16716.html#component-hub)*"
      },
      "sm2135": {
        "docs": "The SM2135 component represents a SM2135 LED diver chain ([SM2135 description](https://github.com/arendst/Sonoff-Tasmota/files/3656603/SM2135E_zh-CN_en-US_translated.pdf), [SM2135 description](https://github.com/arendst/Sonoff-Tasmota/files/3656603/SM2135E_zh-CN_en-US_translated.pdf)) in ESPHome. Communication is done with two GPIO pins (MOSI and SCLK). It is used in some smart light bulbs:\n\n*See also: [sm2135 Component/Hub](https://esphome.io/components/output/sm2135.html#component-hub)*"
      },
      "sml": {
        "dependencies": [
          "uart"
        ],
        "docs": "The `SML` component connects to smart meters which use the *Smart Message Language* (SML) protocol.\n\n*See also: [SML (Smart Message Language)](https://esphome.io/components/sml.html#sml-smart-message-language)*"
      },
      "sn74hc595": {
        "docs": "The SN74HC595 component allows you to use SN74HC595 shift registers as I/O expanders ([datasheet](http://www.ti.com/lit/ds/symlink/sn74hc595.pdf), [SparkFun](https://www.sparkfun.com/products/13699)) in ESPHome. It uses 3 wires (optionally 4) for communication.\n\n*See also: [SN74HC595 I/O Expander (shift register)](https://esphome.io/components/sn74hc595.html#sn74hc595-i-o-expander-shift-register)*"
      },
      "socket": {},
      "spi": {
        "docs": "SPI is a very common high-speed protocol for a lot of devices. The SPI bus usually consists of 4 wires:\n\n*See also: [SPI Bus](https://esphome.io/components/spi.html#spi-bus)*"
      },
      "sprinkler": {
        "docs": "The `sprinkler` controller component aims to behave like a sprinkler/irrigation valve controller, much like those made by companies such as Rain Bird or Hunter. It does so by automating control of a number of [switch](https://esphome.io/components/switch/index.html#config-switch) components, each of which would typically be used to control an individual electric valve via a relay or other switching device. It provides a number of features you\u2019d expect of a sprinkler controller, including:\n\n*See also: [Sprinkler Controller](https://esphome.io/components/sprinkler.html#sprinkler-controller)*"
      },
      "status_led": {
        "docs": "The `status_led` hooks into all ESPHome components and can indicate the status of the device. Specifically, it will:\n\n*See also: [Status LED](https://esphome.io/components/status_led.html#status-led)*"
      },
      "substitutions": {},
      "sun": {
        "docs": "The `sun` component allows you to track the sun\u2019s position in the sky. Calculations are done every 60 seconds.\n\n*See also: [Sun](https://esphome.io/components/sun.html#sun)*"
      },
      "sx1509": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The SX1509 component allows you to expand your I/O capabilities: ([datasheet](https://www.semtech.com/uploads/documents/sx1509_evk_users_guide.pdf), [SparkFun](https://learn.sparkfun.com/tutorials/sx1509-io-expander-breakout-hookup-guide/all)) in ESPHome. It uses [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) for communication.\n\n*See also: [SX1509 16 channel I/O Expander with LED driver and keypad engine](https://esphome.io/components/sx1509.html#sx1509-16-channel-i-o-expander-with-led-driver-and-keypad-engine)*"
      },
      "tca9548a": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The TCA9548A component allows you to use TCA9548A as a I\u00b2C multiplexer ([datasheet](https://www.ti.com/lit/ds/symlink/tca9548a.pdf), [AdaFruit](https://learn.adafruit.com/adafruit-tca9548a-1-to-8-i2c-multiplexer-breakout)) in ESPHome. It uses [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) for communication.\n\n*See also: [TCA9548A I\u00b2C Multiplexer](https://esphome.io/components/tca9548a.html#tca9548a-i2c-multiplexer)*"
      },
      "teleinfo": {
        "docs": "The `teleinfo` component allows you to retrieve data from a French electrical counter using Teleinformation ([datasheet](https://www.enedis.fr/sites/default/files/Enedis-NOI-CPT_54E.pdf)). It works with Linky electrical counter but also legacy EDF electrical counter.\n\n*See also: [teleinfo Component/Hub](https://esphome.io/components/sensor/teleinfo.html#component-hub)*"
      },
      "tlc59208f": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The TLC59208F component represents a Texas Instruments TLC59208F 8-bit PWM driver ([datasheet](http://www.ti.com/lit/gpn/tlc59208f), [hw example](https://faboplatform.github.io/ArduinoDocs/03.I2C%20Brick/211_brick_i2c_7seg/)) in ESPHome. It uses [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) for communication.\n\n*See also: [tlc59208f Component/Hub](https://esphome.io/components/output/tlc59208f.html#component-hub)*"
      },
      "tlc5947": {
        "docs": "This component represents a chain of [TLC5947 24-Channel, 12-Bit PWM LED Drivers](https://www.ti.com/lit/ds/symlink/tlc5947.pdf), which is used e.g. on this [board from Adafruit](https://www.adafruit.com/product/1429).\n\n*See also: [tlc5947 Component/Hub](https://esphome.io/components/output/tlc5947.html#component-hub)*"
      },
      "tm1651": {
        "docs": "The `tm1651` display platform allows you to use battery display units based on TM1651 chip, like [this one](https://aliexpress.com/item/32811491559.html) with ESPHome. Currently integration supports level and brightness setting. All updates can be made via lambda expressions.\n\n*See also: [TM1651 Battery Display](https://esphome.io/components/tm1651.html#tm1651-battery-display)*"
      },
      "ttp229_bsf": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The configuration is made up of two parts: The central component, and individual Binary sensors per channel.\n\n*See also: [ttp229_bsf Component](https://esphome.io/components/binary_sensor/ttp229.html#ttp229-bsf-component)*"
      },
      "ttp229_lsf": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The configuration is made up of two parts: The central component, and individual Binary sensors per channel.\n\n*See also: [ttp229_lsf Component](https://esphome.io/components/binary_sensor/ttp229.html#ttp229-lsf-component)*"
      },
      "tuya": {
        "dependencies": [
          "uart"
        ],
        "docs": "The `tuya` component creates a serial connection to the Tuya MCU for platforms to use.\n\n*See also: [Tuya MCU](https://esphome.io/components/tuya.html#tuya-mcu)*"
      },
      "uart": {
        "docs": "UART is a common serial protocol for a lot of devices. For example, when uploading a binary to your ESP you have probably used UART to access the chip. UART (or for Arduino often also called Serial) usually consists of 2 pins:\n\n*See also: [UART Bus](https://esphome.io/components/uart.html#uart-bus)*"
      },
      "web_server": {
        "docs": "The `web_server` component creates a simple web server on the node that can be accessed through any browser and a simple [REST API](https://esphome.io/web-api/index.html). Please note that enabling this component will take up *a lot* of memory and can lead to problems, especially on the ESP8266.\n\n*See also: [Web Server Component](https://esphome.io/components/web_server.html#web-server-component)*"
      },
      "web_server_base": {
        "dependencies": [
          "network"
        ]
      },
      "wifi": {
        "docs": "WPA2_EAP Enterprise Authentication is supported on ESP32s and ESP8266s. In order to configure this feature you must use the [Connecting to Multiple Networks](https://esphome.io/components/wifi.html#wifi-networks) style configuration. The ESP32 is known to work with PEAP, EAP-TTLS, and the certificate based EAP-TLS. These are advanced settings and you will usually need to consult your enterprise network administrator.\n\n*See also: [Enterprise Authentication](https://esphome.io/components/wifi.html#enterprise-authentication)*"
      },
      "wled": {},
      "xiaomi_ble": {
        "dependencies": [
          "esp32_ble_tracker"
        ]
      },
      "xiaomi_rtcgq02lm": {
        "dependencies": [
          "esp32_ble_tracker"
        ]
      },
      "xpt2046": {}
    },
    "action": {
      "delay": {
        "templatable": true,
        "type": "schema",
        "schema": {
          "extends": [
            "core.positive_time_period_milliseconds"
          ]
        },
        "docs": "This action delays the execution of the next action in the action list by a specified time period.\n\n*See also: [`delay` Action](https://esphome.io/guides/automations.html#delay-action)*"
      },
      "if": {
        "type": "schema",
        "schema": {
          "config_vars": {
            "condition": {
              "key": "Required",
              "type": "registry",
              "registry": "condition",
              "docs": "**[All Conditions](https://esphome.io/guides/automations.html#config-condition)**: The condition to check which branch to take. See [Conditions](https://esphome.io/guides/automations.html#config-condition).\n\n*See also: [Global Variables](https://esphome.io/guides/automations.html#if-action)*"
            },
            "then": {
              "key": "Optional",
              "is_list": true,
              "type": "registry",
              "registry": "action",
              "docs": "**[Action](https://esphome.io/guides/automations.html#config-action)**: The action to perform if the condition evaluates to true. Defaults to doing nothing.\n\n*See also: [Global Variables](https://esphome.io/guides/automations.html#if-action)*"
            },
            "else": {
              "key": "Optional",
              "is_list": true,
              "type": "registry",
              "registry": "action",
              "docs": "**[Action](https://esphome.io/guides/automations.html#config-action)**: The action to perform if the condition evaluates to false. Defaults to doing nothing.\n\n*See also: [Global Variables](https://esphome.io/guides/automations.html#if-action)*"
            }
          }
        },
        "docs": "This action first evaluated a certain condition (`if:`) and then either executes the `then:` branch or the `else:` branch depending on the output of the condition.\n\n*See also: [`if` Action](https://esphome.io/guides/automations.html#if-action)*"
      },
      "while": {
        "type": "schema",
        "schema": {
          "config_vars": {
            "condition": {
              "key": "Required",
              "type": "registry",
              "registry": "condition",
              "docs": "The condition to check whether to execute. See [Conditions](https://esphome.io/guides/automations.html#config-condition).\n\n*See also: [Global Variables](https://esphome.io/guides/automations.html#while-action)*"
            },
            "then": {
              "key": "Required",
              "is_list": true,
              "type": "registry",
              "registry": "action",
              "docs": "**[Action](https://esphome.io/guides/automations.html#config-action)**: The action to perform until the condition evaluates to false.\n\n*See also: [Global Variables](https://esphome.io/guides/automations.html#while-action)*"
            }
          }
        },
        "docs": "This action is similar to the [if](https://esphome.io/guides/automations.html#if-action) Action. The `while` action executes a block until a given condition evaluates to false.\n\n*See also: [`while` Action](https://esphome.io/guides/automations.html#while-action)*"
      },
      "repeat": {
        "type": "schema",
        "schema": {
          "config_vars": {
            "count": {
              "key": "Required",
              "templatable": true,
              "type": "integer",
              "data_type": "positive_not_null_int",
              "docs": "**int**: The number of times the action should be repeated.\n\n*See also: [Global Variables](https://esphome.io/guides/automations.html#repeat-action)*"
            },
            "then": {
              "key": "Required",
              "is_list": true,
              "type": "registry",
              "registry": "action",
              "docs": "**[Action](https://esphome.io/guides/automations.html#config-action)**: The action to repeat.\n\n*See also: [Global Variables](https://esphome.io/guides/automations.html#repeat-action)*"
            }
          }
        },
        "docs": "This action allows you to repeat a block a given number of times. For example, the automation below will flash the light five times.\n\n*See also: [`repeat` Action](https://esphome.io/guides/automations.html#repeat-action)*"
      },
      "wait_until": {
        "type": "schema",
        "maybe": "condition",
        "schema": {
          "config_vars": {
            "condition": {
              "key": "Required",
              "type": "registry",
              "registry": "condition",
              "docs": "The condition to wait to become true. See [Conditions](https://esphome.io/guides/automations.html#config-condition).\n\n*See also: [Global Variables](https://esphome.io/guides/automations.html#wait-until-action)*"
            },
            "timeout": {
              "key": "Optional",
              "templatable": true,
              "type": "schema",
              "schema": {
                "extends": [
                  "core.positive_time_period_milliseconds"
                ]
              },
              "docs": "**[Time](https://esphome.io/guides/configuration-types.html#config-time)**: Time to wait before timing out. Defaults to never timing out.\n\n*See also: [Global Variables](https://esphome.io/guides/automations.html#wait-until-action)*"
            }
          }
        },
        "docs": "This action allows your automations to wait until a condition evaluates to true. (So this is just a shorthand way of writing a `while` action with an empty `then` block.)\n\n*See also: [`wait_until` Action](https://esphome.io/guides/automations.html#wait-until-action)*"
      },
      "lambda": {
        "docs": "This action executes an arbitrary piece of C++ code (see [Lambda](https://esphome.io/guides/automations.html#config-lambda)).\n\n*See also: [`lambda` Action](https://esphome.io/guides/automations.html#lambda-action)*"
      }
    },
    "condition": {
      "and": {
        "is_list": true,
        "type": "registry",
        "registry": "condition"
      },
      "or": {
        "is_list": true,
        "type": "registry",
        "registry": "condition"
      },
      "not": {
        "type": "registry",
        "registry": "condition"
      },
      "lambda": {
        "docs": "This condition performs an arbitrary piece of C++ code (see [Lambda](https://esphome.io/guides/automations.html#config-lambda)) and can be used to create conditional flow in actions.\n\n*See also: [`lambda` Condition](https://esphome.io/guides/automations.html#lambda-condition)*"
      },
      "for": {
        "type": "schema",
        "schema": {
          "config_vars": {
            "time": {
              "key": "Required",
              "templatable": true,
              "type": "schema",
              "schema": {
                "extends": [
                  "core.positive_time_period_milliseconds"
                ]
              },
              "docs": "**[templatable](https://esphome.io/guides/automations.html#config-templatable), [Time](https://esphome.io/guides/configuration-types.html#config-time)**: The time for which the condition has to have been true.\n\n*See also: [script Component](https://esphome.io/guides/automations.html#for-condition)*"
            },
            "condition": {
              "key": "Required",
              "type": "registry",
              "registry": "condition",
              "docs": "**[Condition](https://esphome.io/guides/automations.html#config-condition)**: The condition to check.\n\n*See also: [script Component](https://esphome.io/guides/automations.html#for-condition)*"
            }
          },
          "extends": [
            "core.COMPONENT_SCHEMA"
          ]
        },
        "docs": "This [Condition](https://esphome.io/guides/automations.html#config-condition) allows you to check if a given condition has been true for at least a given amount of time.\n\n*See also: [`for` Condition](https://esphome.io/guides/automations.html#for-condition)*"
      }
    },
    "pins": [
      "esp32",
      "esp8266",
      "mcp23xxx",
      "mcp23016",
      "pcf8574",
      "rp2040",
      "sn74hc595",
      "sx1509"
    ]
  }
}