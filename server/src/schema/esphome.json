{
  "esphome": {
    "schemas": {
      "CONFIG_SCHEMA": {
        "type": "schema",
        "schema": {
          "config_vars": {
            "name": {
              "key": "Required",
              "type": "string",
              "docs": "**string**: This is the name of the node. It should always be unique in your ESPHome network. May only contain lowercase characters, digits and hyphens, and can be at most 24 characters long by default, or 31 characters long if `name_add_mac_suffix` is `false`. See [Changing ESPHome Node Name](https://esphome.io/components/esphome.html#esphome-changing-node-name).\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
            },
            "friendly_name": {
              "key": "Optional",
              "default": "",
              "type": "string",
              "docs": "**string**: This is the name sent to the frontend. It is used by Home Assistant as the integration name, device name, and is automatically prefixed to entities where necessary.\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
            },
            "comment": {
              "key": "Optional",
              "type": "string",
              "docs": "**string**: Additional text information about this node. Only for display in UI.\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
            },
            "build_path": {
              "key": "Required",
              "type": "string",
              "docs": "**string**: Customize where ESPHome will store the build files for your node. By default, ESPHome puts the PlatformIO project it uses to build the firmware in the `.esphome/build/<NODE>` directory, but you can customize this behavior using this option.\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
            },
            "platformio_options": {
              "key": "String",
              "default": "{}",
              "key_type": "string_strict",
              "type": "schema",
              "schema": {
                "config_vars": {
                  "string": {
                    "type": "string"
                  }
                }
              },
              "docs": "**mapping**: Additional options to pass over to PlatformIO in the platformio.ini file. See [platformio_options](https://esphome.io/components/esphome.html#esphome-platformio-options).\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
            },
            "on_boot": {
              "key": "Optional",
              "type": "trigger",
              "schema": {
                "config_vars": {
                  "priority": {
                    "key": "Optional",
                    "default": "600.0",
                    "docs": "**float**: The priority to execute your custom initialization code. A higher value means a high priority and thus also your code being executed earlier. Please note this is an ESPHome-internal value and any change will not be marked as a breaking change. Defaults to `600`. Priorities (you can use any value between them too):\n  * `800.0`: This is where all hardware initialization of vital components is executed. For example setting switches to their initial state.\n  \n  * `600.0`: This is where most sensors are set up.\n  \n  * `250.0`: At this priority, WiFi is initialized.\n  \n  * `200.0`: Network connections like MQTT/native API are set up at this priority.\n  \n  * `-100.0`: At this priority, pretty much everything should already be initialized.\n  \n  \n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#on-boot)*"
                  },
                  "then": {
                    "type": "trigger"
                  }
                }
              },
              "docs": "**[Automation](https://esphome.io/guides/automations.html#automation)**: An automation to perform when the node starts. See [on_boot](https://esphome.io/components/esphome.html#esphome-on-boot).\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
            },
            "on_shutdown": {
              "key": "Optional",
              "type": "trigger",
              "schema": {
                "config_vars": {
                  "priority": {
                    "key": "Optional",
                    "default": "600.0",
                    "docs": "**float**: The priority to execute your custom shutdown code. A higher value means a high priority and in case of shutdown triggers that the code is executed **later**. Priority is used primarily for the initialization order of components. Shutdowns for these components are handled in *reverse* order, such that e.g. sensors (600) are shutdown before the hardware components (800) they depend on. Please note this is an ESPHome-internal value and any change will not be marked as a breaking change. Defaults to `600`. For priority values refer to the list in the [on_boot](https://esphome.io/components/esphome.html#esphome-on-boot) section.\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#on-shutdown)*"
                  },
                  "then": {
                    "type": "trigger"
                  }
                }
              },
              "docs": "**[Automation](https://esphome.io/guides/automations.html#automation)**: An automation to perform right before the node shuts down. See [on_shutdown](https://esphome.io/components/esphome.html#esphome-on-shutdown).\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
            },
            "on_loop": {
              "key": "Optional",
              "type": "trigger",
              "docs": "**[Automation](https://esphome.io/guides/automations.html#automation)**: An automation to perform on each `loop()` iteration. See [on_loop](https://esphome.io/components/esphome.html#esphome-on-loop).\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
            },
            "includes": {
              "key": "Optional",
              "default": "[]",
              "is_list": true,
              "docs": "**list of files**: A list of C/C++ files to include in the main (auto-generated) sketch file for custom components. The paths in this list are relative to the directory where the YAML configuration file is in. See [includes](https://esphome.io/components/esphome.html#esphome-includes).\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
            },
            "libraries": {
              "key": "Optional",
              "default": "[]",
              "is_list": true,
              "type": "string",
              "docs": "**list of libraries**: A list of libraries to include in the project. See [libraries](https://esphome.io/components/esphome.html#esphome-libraries).\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
            },
            "name_add_mac_suffix": {
              "key": "Optional",
              "default": "False",
              "type": "boolean",
              "docs": "**boolean**: Appends the last 3 bytes of the mac address of the device to the name in the form `<name>-aabbcc`. Defaults to `false`. See [Adding the MAC address as a suffix to the device name](https://esphome.io/components/esphome.html#esphome-mac-suffix).\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
            },
            "project": {
              "key": "Optional",
              "type": "schema",
              "schema": {
                "config_vars": {
                  "name": {
                    "key": "Required",
                    "type": "string",
                    "docs": "**string**: Name of the project\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
                  },
                  "version": {
                    "key": "Required",
                    "type": "string",
                    "docs": "**string**: Version of the project\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
                  }
                }
              },
              "docs": "ESPHome Creator\u2019s Project information. See [Project information](https://esphome.io/components/esphome.html#esphome-creators-project).\n  * **name** (**Required**, string): Name of the project\n  \n  * **version** (**Required**, string): Version of the project\n  \n  \n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
            },
            "min_version": {
              "key": "Optional",
              "default": "2023.9.3",
              "docs": "**string**: The minimum ESPHome version required to compile this configuration. See [Minimum ESPHome version](https://esphome.io/components/esphome.html#esphome-min-version).\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
            },
            "compile_process_limit": {
              "key": "Optional",
              "type": "integer",
              "docs": "**int**: The maximum number of simultaneous compile processes to run. Defaults to the number of cores of the CPU which is also the maximum you can set.\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
            }
          }
        }
      }
    }
  },
  "core": {
    "schemas": {
      "time_period_dict": {
        "type": "schema",
        "schema": {
          "config_vars": {
            "days": {
              "key": "Optional"
            },
            "hours": {
              "key": "Optional"
            },
            "minutes": {
              "key": "Optional"
            },
            "seconds": {
              "key": "Optional"
            },
            "milliseconds": {
              "key": "Optional"
            },
            "microseconds": {
              "key": "Optional"
            }
          }
        }
      },
      "positive_time_period_milliseconds": {
        "type": "schema",
        "schema": {
          "extends": [
            "core.time_period_dict"
          ]
        }
      },
      "positive_time_period_seconds": {
        "type": "schema",
        "schema": {
          "extends": [
            "core.time_period_dict"
          ]
        }
      },
      "positive_time_period_minutes": {
        "type": "schema",
        "schema": {
          "extends": [
            "core.time_period_dict"
          ]
        }
      },
      "positive_time_period_microseconds": {
        "type": "schema",
        "schema": {
          "extends": [
            "core.time_period_dict"
          ]
        }
      },
      "MQTT_COMPONENT_SCHEMA": {
        "type": "schema",
        "schema": {
          "config_vars": {
            "retain": {
              "key": "Optional",
              "type": "boolean",
              "docs": "**boolean**: If all MQTT state messages should be retained. Defaults to `true`.\n\n*See also: [MQTT Component Base Configuration](https://esphome.io/components/mqtt.html#mqtt-component-base-configuration)*"
            },
            "discovery": {
              "key": "Optional",
              "type": "boolean",
              "docs": "**boolean**: Manually enable/disable discovery for a component. Defaults to the global default.\n\n*See also: [MQTT Component Base Configuration](https://esphome.io/components/mqtt.html#mqtt-component-base-configuration)*"
            },
            "state_topic": {
              "key": "Optional",
              "docs": "**string**: The topic to publish state updates to. Defaults to `<TOPIC_PREFIX>/<COMPONENT_TYPE>/<COMPONENT_NAME>/state`.\n\n*See also: [MQTT Component Base Configuration](https://esphome.io/components/mqtt.html#mqtt-component-base-configuration)*"
            },
            "availability": {
              "key": "Optional",
              "type": "schema",
              "schema": {
                "config_vars": {
                  "topic": {
                    "key": "Required"
                  },
                  "payload_available": {
                    "key": "Optional",
                    "default": "online"
                  },
                  "payload_not_available": {
                    "key": "Optional",
                    "default": "offline"
                  }
                }
              },
              "docs": "Manually set what should be sent to Home Assistant for showing entity availability. Default derived from [global birth/last will message](https://esphome.io/components/mqtt.html#mqtt-last-will-birth).\n\n*See also: [MQTT Component Base Configuration](https://esphome.io/components/mqtt.html#mqtt-component-base-configuration)*"
            }
          }
        }
      },
      "COMPONENT_SCHEMA": {
        "type": "schema",
        "schema": {
          "config_vars": {
            "setup_priority": {
              "key": "Optional"
            }
          }
        }
      },
      "MQTT_COMMAND_COMPONENT_SCHEMA": {
        "type": "schema",
        "schema": {
          "extends": [
            "core.MQTT_COMPONENT_SCHEMA"
          ],
          "config_vars": {
            "command_topic": {
              "key": "Optional",
              "docs": "**string**: The topic to subscribe to for commands from the remote. Defaults to `<TOPIC_PREFIX>/<COMPONENT_TYPE>/<COMPONENT_NAME>/command`.\n\n*See also: [MQTT Component Base Configuration](https://esphome.io/components/mqtt.html#mqtt-component-base-configuration)*"
            },
            "command_retain": {
              "key": "Optional",
              "type": "boolean",
              "docs": "**boolean**: Whether MQTT command messages sent to the device should be retained or not. Default to `false`.\n\n*See also: [MQTT Component Base Configuration](https://esphome.io/components/mqtt.html#mqtt-component-base-configuration)*"
            },
            "name": {
              "docs": "**string**: The name to use for the MQTT Component.\n\n*See also: [MQTT Component Base Configuration](https://esphome.io/components/mqtt.html#mqtt-component-base-configuration)*"
            }
          }
        }
      },
      "ENTITY_BASE_SCHEMA": {
        "type": "schema",
        "schema": {
          "config_vars": {
            "name": {
              "key": "Optional",
              "type": "string",
              "docs": "**string**: The name for the binary sensor.\n\n*See also: [touchscreen Binary Sensor](https://esphome.io/components/touchscreen/index.html#id1)*"
            },
            "internal": {
              "key": "Optional",
              "type": "boolean",
              "docs": "**boolean**: Mark this component as internal. Internal components will not be exposed to the frontend (like Home Assistant). Only specifying an `id` without a `name` will implicitly set this to true.\n\n*See also: [Text Sensor Component](https://esphome.io/components/text_sensor/index.html#base-text-sensor-configuration)*"
            },
            "disabled_by_default": {
              "key": "Optional",
              "default": "False",
              "type": "boolean",
              "docs": "**boolean**: If true, then this entity should not be added to any client\u2019s frontend, (usually Home Assistant) without the user manually enabling it (via the Home Assistant UI). Requires Home Assistant 2021.9 or newer. Defaults to `false`.\n\n*See also: [Text Sensor Component](https://esphome.io/components/text_sensor/index.html#base-text-sensor-configuration)*"
            },
            "icon": {
              "key": "Optional",
              "docs": "**icon**: Manually set the icon to use for the sensor in the frontend.\n\n*See also: [Text Sensor Component](https://esphome.io/components/text_sensor/index.html#base-text-sensor-configuration)*"
            },
            "entity_category": {
              "key": "Optional",
              "docs": "**string**: The category of the entity. See [https://developers.home-assistant.io/docs/core/entity/#generic-properties](https://developers.home-assistant.io/docs/core/entity/#generic-properties) for a list of available options. Requires Home Assistant 2021.11 or newer. Set to `\"\"` to remove the default entity category.\n\n*See also: [Text Sensor Component](https://esphome.io/components/text_sensor/index.html#base-text-sensor-configuration)*"
            }
          }
        }
      },
      "SOURCE_SCHEMA": {
        "type": "typed",
        "types": {
          "git": {
            "config_vars": {
              "url": {
                "key": "Required",
                "docs": "**url**: HTTP git repository url. See [Git](https://esphome.io/components/external_components.html#external-components-git).\n\n*See also: [External Components](https://esphome.io/components/external_components.html#external-components)*"
              },
              "ref": {
                "key": "Optional",
                "docs": "**string**: Git ref (branch or tag). If not specified the default branch is used.\n\n*See also: [External Components](https://esphome.io/components/external_components.html#external-components)*"
              },
              "username": {
                "key": "Optional",
                "type": "string",
                "docs": "**string**: Username for the Git server, if one is required\n\n*See also: [External Components](https://esphome.io/components/external_components.html#external-components)*"
              },
              "password": {
                "key": "Optional",
                "type": "string",
                "docs": "**string**: Password for the Git server, if one is required\n\n*See also: [External Components](https://esphome.io/components/external_components.html#external-components)*"
              }
            }
          },
          "local": {
            "config_vars": {
              "path": {
                "key": "Required",
                "docs": "Path to use when using local components. See [Local](https://esphome.io/components/external_components.html#external-components-local).\n\n*See also: [External Components](https://esphome.io/components/external_components.html#external-components)*"
              }
            }
          }
        },
        "typed_key": "type",
        "docs": "Repository type. One of `local`, `git`.\n\n*See also: [External Components](https://esphome.io/components/external_components.html#external-components)*"
      }
    },
    "platforms": {
      "sensor": {
        "docs": "ESPHome has support for many different sensors. Each of them is a platform of the `sensor` domain and each sensor has several base configuration options.\n\n*See also: [Sensor Component](https://esphome.io/components/sensor/index.html#sensor-component)*"
      },
      "alarm_control_panel": {
        "docs": "Configuration variables:\n\n*See also: [Alarm Control Panel Component](https://esphome.io/components/alarm_control_panel/index.html#alarm-control-panel-component)*"
      },
      "binary_sensor": {
        "docs": "With ESPHome you can use different types of binary sensors. They will automatically appear in the Home Assistant front-end and have several configuration options.\n\n*See also: [Binary Sensor Component](https://esphome.io/components/binary_sensor/index.html#binary-sensor-component)*"
      },
      "button": {
        "docs": "To attach a physical button to ESPHome, see [GPIO Binary Sensor](https://esphome.io/components/binary_sensor/gpio.html).\n\n*See also: [Button Component](https://esphome.io/components/button/index.html#button-component)*"
      },
      "canbus": {
        "docs": "Each canbus platform extends this configuration schema.\n\n*See also: [Base CAN Bus Configuration](https://esphome.io/components/canbus.html#base-can-bus-configuration)*"
      },
      "climate": {
        "docs": "ESPHome has support for climate devices. Climate devices can represent different types of hardware, but the defining factor is that climate devices have a settable target temperature and can be put in different modes like `HEAT`, `COOL`, `HEAT_COOL` or `OFF`.\n\n*See also: [Climate Component](https://esphome.io/components/climate/index.html#climate-component)*"
      },
      "cover": {
        "docs": "The `cover` component is a generic representation of covers in ESPHome. A cover can (currently) either be *closed* or *open* and supports three types of commands: *open*, *close* and *stop*.\n\n*See also: [Cover Component](https://esphome.io/components/cover/index.html#cover-component)*"
      },
      "display": {},
      "fan": {
        "docs": "With the `fan` domain you can create components that appear as fans in the Home Assistant frontend. A fan can be switched on or off, optionally has a speed between 1 and the maximum supported speed of the fan, and can have an oscillation and direction output.\n\n*See also: [Fan Component](https://esphome.io/components/fan/index.html#fan-component)*"
      },
      "light": {
        "docs": "The `light` domain in ESPHome lets you create lights that will automatically be shown in Home Assistant\u2019s frontend and have many features such as RGB colors, transitions, flashing and effects.\n\n*See also: [Light Component](https://esphome.io/components/light/index.html#light-component)*"
      },
      "lock": {
        "docs": "The `lock` domain includes all platforms that should function like a lock with lock/unlock actions.\n\n*See also: [Lock Component](https://esphome.io/components/lock/index.html#lock-component)*"
      },
      "media_player": {
        "docs": "The `media_player` domain includes all platforms that implement media player functionality.\n\n*See also: [Media Player Components](https://esphome.io/components/media_player/index.html#media-player-components)*"
      },
      "microphone": {
        "docs": "The `microphone` domain contains common functionality shared across the microphone platforms.\n\n*See also: [Microphone Components](https://esphome.io/components/microphone/index.html#microphone-components)*"
      },
      "number": {
        "docs": "ESPHome has support for components to create a number entity. A number entity is like a sensor that can read a value from a device, but is useful when that value can be set by the user/frontend.\n\n*See also: [Number Component](https://esphome.io/components/number/index.html#number-component)*"
      },
      "output": {
        "docs": "Each output platform extends this configuration schema.\n\n*See also: [Base Output Configuration](https://esphome.io/components/output/index.html#base-output-configuration)*"
      },
      "select": {
        "docs": "ESPHome has support for components to create a select entity. A select entity is basically an option list that can be set by either yaml, hardware or the user/frontend.\n\n*See also: [Select Component](https://esphome.io/components/select/index.html#select-component)*"
      },
      "speaker": {},
      "stepper": {
        "docs": "The `stepper` component allows you to use stepper motors with ESPHome. Currently only the A4988 stepper driver ([datasheet](https://www.pololu.com/file/0J450/a4988_DMOS_microstepping_driver_with_translator.pdf)) and ULN2003 ([datasheet](http://www.ti.com/lit/ds/symlink/uln2003a.pdf)) are supported.\n\n*See also: [Stepper Component](https://esphome.io/components/stepper/index.html#stepper-component)*"
      },
      "switch": {
        "docs": "The `switch` domain includes all platforms that should show up like a switch and can only be turned ON or OFF.\n\n*See also: [Switch Component](https://esphome.io/components/switch/index.html#switch-component)*"
      },
      "text_sensor": {
        "docs": "Text sensors are a lot like normal [sensors](https://esphome.io/components/sensor/index.html). But where the \u201cnormal\u201d sensors only represent sensors that output **numbers**, this component can represent any *text*.\n\n*See also: [Text Sensor Component](https://esphome.io/components/text_sensor/index.html#text-sensor-component)*"
      },
      "time": {
        "docs": "The `time` component allows you to set up real time clock time sources for ESPHome. You can then get the current time in [lambdas](https://esphome.io/guides/automations.html#config-lambda).\n\n*See also: [Time Component](https://esphome.io/components/time/index.html#time-component)*"
      },
      "touchscreen": {
        "docs": "The `touchscreen` component holds the base code for most touchscreen components available in ESPHome and is responsible for passing the touch events to `binary_sensors` with the `touchscreen` platform.\n\n*See also: [Touchscreen Components](https://esphome.io/components/touchscreen/index.html#touchscreen-components)*"
      }
    },
    "components": {
      "esphome": {
        "docs": "Here you specify some core information that ESPHome needs to create firmwares. Most importantly, this is the section of the configuration where you specify the **name** of the node.\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#esphome-core-configuration)*"
      },
      "esp32": {
        "docs": "This is an alternative base framework for ESP32 chips, and recommended for variants of the ESP32 like ESP32S2, ESP32S3, ESP32C3 and single-core ESP32 chips.\n\n*See also: [ESP-IDF framework](https://esphome.io/components/esp32.html#esp-idf-framework)*"
      },
      "esp8266": {
        "docs": "This component contains platform-specific options for the ESP8266 platform.\n\n*See also: [ESP8266 Platform](https://esphome.io/components/esp8266.html#esp8266-platform)*"
      },
      "adalight": {
        "dependencies": [
          "uart"
        ]
      },
      "adc128s102": {
        "dependencies": [
          "spi"
        ],
        "docs": "The ADC128S102 component allows you to use ADC128S102 8-Channel 12-Bit A/D Converter ([datasheet](https://www.ti.com/lit/ds/symlink/adc128s102.pdf), [Texas Instruments](https://www.ti.com/product/ADC128S102)) in ESPHome. It uses the [SPI Bus](https://esphome.io/components/spi.html#spi) for communication.\n\n*See also: [adc128s102 Component/Hub](https://esphome.io/components/sensor/adc128s102.html#component-hub)*"
      },
      "ads1115": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The `ads1115` domain creates a global hub so that you can later create individual sensors using the [ADS1115 Sensor Platform](https://esphome.io/components/sensor/ads1115.html#ads1115-sensor). To use this hub, first setup the [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) and connect the sensor to the pins specified there.\n\n*See also: [ads1115 Component/Hub](https://esphome.io/components/sensor/ads1115.html#component-hub)*"
      },
      "airthings_ble": {
        "dependencies": [
          "esp32_ble_tracker"
        ]
      },
      "animation": {
        "dependencies": [
          "display"
        ],
        "docs": "Allows to use animated images on displays. Animation inherits all options from the image component. It adds additional lambda methods: `next_frame()`, `prev_frame()` and `set_frame()` to change the shown picture of a gif.\n\n*See also: [Animation](https://esphome.io/components/display/index.html#animation)*"
      },
      "apds9960": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The `apds9960` sensor platform allows you to use your APDS9960 RGB and gesture sensors ([datasheet](https://cdn.sparkfun.com/datasheets/Sensors/Proximity/apds9960.pdf), [SparkFun](https://www.sparkfun.com/products/12787)) with ESPHome. The [I\u00b2C](https://esphome.io/components/i2c.html#i2c) is required to be set up in your configuration for this sensor to work.\n\n*See also: [apds9960 Component/Hub](https://esphome.io/components/sensor/apds9960.html#component-hub)*"
      },
      "api": {
        "dependencies": [
          "network"
        ],
        "docs": "The ESPHome native API is used to communicate with clients directly, with a highly-optimized network protocol. Currently, only the ESPHome tool and Home Assistant use this native API.\n\n*See also: [Native API Component](https://esphome.io/components/api.html#native-api-component)*"
      },
      "as3935_i2c": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The `as3935_i2c` sensor platform allows you to use your AS3935 sensor ([AliExpress](https://de.aliexpress.com/af/as3935.html?SearchText=as3935), [AMS_AS3935](https://ams.com/as3935)) in order to get notified when a thunderstorm is getting close.\n\n*See also: [as3935 Over I\u00b2C](https://esphome.io/components/sensor/as3935.html#over-i2c)*"
      },
      "as3935_spi": {
        "dependencies": [
          "spi"
        ],
        "docs": "The `as3935_spi` sensor platform allows you to use your AS3935 sensor ([AliExpress](https://de.aliexpress.com/af/as3935.html?SearchText=as3935), [AMS_AS3935](https://ams.com/as3935)) in order to get notified when a thunderstorm is getting close.\n\n*See also: [as3935 Over SPI](https://esphome.io/components/sensor/as3935.html#over-spi)*"
      },
      "async_tcp": {},
      "bedjet": {
        "dependencies": [
          "ble_client"
        ],
        "docs": "This component is a global hub that maintains the connection to the BedJet device and delegates status updates to individual platform components.\n\n*See also: [bedjet Component/Hub](https://esphome.io/components/climate/bedjet.html#component-hub)*"
      },
      "bk72xx": {
        "docs": "This component contains platform-specific options for the [LibreTiny](https://docs.libretiny.eu/) platform. It provides support for the following microcontrollers:\n\n*See also: [LibreTiny Platform](https://esphome.io/components/libretiny.html#libretiny-platform)*"
      },
      "ble_client": {
        "dependencies": [
          "esp32_ble_tracker"
        ],
        "docs": "The `ble_client` component enables connections to Bluetooth Low Energy devices in order to query and control them. This component does not expose any sensors or output components itself, but merely manages connections to them for use by other components.\n\n*See also: [BLE Client](https://esphome.io/components/ble_client.html#ble-client)*"
      },
      "bluetooth_proxy": {
        "dependencies": [
          "api",
          "esp32"
        ],
        "docs": "Home Assistant can expand its Bluetooth reach by communicating through the Bluetooth proxy component in ESPHome. The individual device integrations in Home Assistant (such as BTHome) will receive the data from the Bluetooth Integration in Home Assistant which automatically aggregates all ESPHome Bluetooth proxies with any USB Bluetooth Adapters you might have. This exceptional feature offers fault tolerant connection between the Bluetooth devices and Home Assistant.\n\n*See also: [Bluetooth Proxy](https://esphome.io/components/bluetooth_proxy.html#bluetooth-proxy)*"
      },
      "bme680_bsec": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The `bme680_bsec` sensor platform allows you to use your BME680 ([datasheet](https://cdn-shop.adafruit.com/product-files/3660/BME680.pdf), [Adafruit](https://www.adafruit.com/product/3660)) temperature, pressure and humidity and gas sensors with ESPHome via the Bosch Sensortec Environmental Cluster (BSEC) software library. The use of Bosch\u2019s proprietary algorithms provide an Index for Air Quality (IAQ) measurement derived from the gas resistance sensor\u2019s response to specific Volatile Organic Compounds (VOC). The BSEC software also provides estimated values for CO\u2082 and Breath Volatile Organic Compounds (b-VOC) using a correlation between VOC and CO\u2082 in a human\u2019s exhaled breath.\n\n*See also: [bme680_bsec Component/Hub](https://esphome.io/components/sensor/bme680_bsec.html#component-hub)*"
      },
      "bp1658cj": {
        "docs": "The BP1658CJ component represents a BP1658CJ LED driver chain in ESPHome. Communication is done with two GPIO pins (DATA and CLK).\n\n*See also: [bp1658cj Component/Hub](https://esphome.io/components/output/bp1658cj.html#component-hub)*"
      },
      "bp5758d": {
        "docs": "The BP5758D component represents a BP5758D LED driver chain in ESPHome. Communication is done with two GPIO pins (DATA and CLK).\n\n*See also: [bp5758d Component/Hub](https://esphome.io/components/output/bp5758d.html#component-hub)*"
      },
      "cap1188": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The `cap1188` sensor platform allows you to use your CAP1188 ([datasheet](https://cdn-shop.adafruit.com/datasheets/CAP1188.pdf), [Adafruit](https://learn.adafruit.com/adafruit-cap1188-breakout/overview)) Capacitive Touch Sensor with ESPHome. The [I\u00b2C](https://esphome.io/components/i2c.html#i2c) bus is required to be set up in your configuration for this sensor to work.\n\n*See also: [cap1188 Component/Hub](https://esphome.io/components/binary_sensor/cap1188.html#component-hub)*"
      },
      "captive_portal": {
        "dependencies": [
          "wifi"
        ],
        "docs": "The captive portal component in ESPHome is a fallback mechanism for when connecting to the configured [WiFi](https://esphome.io/components/wifi.html) fails.\n\n*See also: [Captive Portal](https://esphome.io/components/captive_portal.html#captive-portal)*"
      },
      "cd74hc4067": {
        "docs": "**[Pin](https://esphome.io/guides/configuration-types.html#config-pin)**: The I/O pins connected to the S0 to S3 channel selection pins\n\n*See also: [cd74hc4067 Component/Hub](https://esphome.io/components/sensor/cd74hc4067.html#component-hub)*"
      },
      "color": {
        "docs": "When using RGB-capable displays in ESPHome you may wish to use custom colors. A `color` component exists for just this purpose:\n\n*See also: [Color](https://esphome.io/components/display/index.html#color)*"
      },
      "custom_component": {
        "docs": "This integration can be used to create generic custom components in ESPHome using the C++ (Arduino) API. This integration should be used in cases where none of ESPHome\u2019s abstraction layers (for example the \u201csensor\u201d, \u201cbinary sensor\u201d, \u201cswitch\u201d, etc concepts) work well for your integration.\n\n*See also: [Generic Custom Component](https://esphome.io/custom/custom_component.html#generic-custom-component)*"
      },
      "dac7678": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The DAC7678 component represents a DAC7678 12-bit 8 channel DAC with internal reference ([datasheet](https://www.ti.com/lit/ds/symlink/dac7678.pdf)) in ESPHome. It uses the [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) for communication.\n\n*See also: [dac7678 Component/Hub](https://esphome.io/components/output/dac7678.html#component-hub)*"
      },
      "dallas": {
        "docs": "The `dallas` component allows you to use your [DS18b20](https://www.adafruit.com/product/374) ([datasheet](https://datasheets.maximintegrated.com/en/ds/DS18B20.pdf)) and similar 1-Wire temperature sensors.\n\n*See also: [dallas Component/Hub](https://esphome.io/components/sensor/dallas.html#component-hub)*"
      },
      "daly_bms": {
        "dependencies": [
          "uart"
        ],
        "docs": "**[Time](https://esphome.io/guides/configuration-types.html#config-time)**: Delay between data requests.\n\n*See also: [daly_bms Component/Hub](https://esphome.io/components/sensor/daly_bms.html#component-hub)*"
      },
      "dashboard_import": {
        "dependencies": [
          "api"
        ]
      },
      "debug": {
        "dependencies": [
          "logger"
        ],
        "docs": "The `debug` component can be used to debug problems with ESPHome. At startup, it prints a bunch of useful information like reset reason, free heap size, ESPHome version and so on. It also allows you to get the same information as a text sensor, and to monitor the state of the ESP heap memory (free space, maximum free block size and fragmentation level) and the main-loop timing.\n\n*See also: [Debug Component](https://esphome.io/components/debug.html#debug-component)*"
      },
      "deep_sleep": {
        "docs": "The `deep_sleep` component can be used to automatically enter a deep sleep mode on the ESP8266/ESP32 after a certain amount of time. This is especially useful with nodes that operate on batteries and therefore need to conserve as much energy as possible.\n\n*See also: [Deep Sleep Component](https://esphome.io/components/deep_sleep.html#deep-sleep-component)*"
      },
      "demo": {
        "docs": "The `demo` integration can be used for testing to generate sample instances of many different integrations (sensors, lights, \u2026)\n\n*See also: [Demo Integration](https://esphome.io/components/demo.html#demo-integration)*"
      },
      "dfplayer": {
        "dependencies": [
          "uart"
        ],
        "docs": "The `dfplayer` ([datasheet](https://wiki.dfrobot.com/DFPlayer_Mini_SKU_DFR0299)), component allows you to play sound and music stored in an SD card or USB flash drive.\n\n*See also: [DF-Player mini](https://esphome.io/components/dfplayer.html#df-player-mini)*"
      },
      "dsmr": {
        "dependencies": [
          "uart"
        ],
        "docs": "The DSMR component connects to Dutch Smart Meters which comply to DSMR (Dutch Smart Meter Requirements), also known as \u2018Slimme meter\u2019 or \u2018P1 port\u2019.\n\n*See also: [dsmr Component/Hub](https://esphome.io/components/sensor/dsmr.html#component-hub)*"
      },
      "e131": {
        "dependencies": [
          "network"
        ],
        "docs": "The [E1.31 Effect](https://esphome.io/components/light/index.html#e131-light-effect) requires a component hub for the `e131` light effect.\n\n*See also: [E1.31 Component](https://esphome.io/components/light/index.html#e1-31-component)*"
      },
      "esp32_ble": {
        "dependencies": [
          "esp32"
        ],
        "docs": "The `esp32_ble` component in ESPHome sets up the Bluetooth LE stack on the device so that a [BLE Server](https://esphome.io/components/esp32_ble_server.html) can run.\n\n*See also: [BLE Component](https://esphome.io/components/esp32_ble.html#ble-component)*"
      },
      "esp32_ble_beacon": {
        "dependencies": [
          "esp32"
        ],
        "docs": "The `esp32_ble_beacon` component creates a Bluetooth Low Energy Beacon with your ESP32 device. Beacons are BLE devices that repeatedly just send out a pre-defined packet of data. This packet can then be received by devices like smartphones and can then be used to track a phone\u2019s location.\n\n*See also: [ESP32 Bluetooth Low Energy Beacon](https://esphome.io/components/esp32_ble_beacon.html#esp32-bluetooth-low-energy-beacon)*"
      },
      "esp32_ble_server": {
        "dependencies": [
          "esp32"
        ],
        "docs": "The `esp32_ble_server` component in ESPHome sets up a simple BLE GATT server that exposes the device name, manufacturer and board. This component allows other components to create their own services to expose data and control.\n\n*See also: [BLE Server](https://esphome.io/components/esp32_ble_server.html#ble-server)*"
      },
      "esp32_ble_tracker": {
        "dependencies": [
          "esp32"
        ],
        "docs": "The `esp32_ble_tracker` component creates a global hub so that you can track bluetooth low energy devices using your ESP32 node.\n\n*See also: [ESP32 Bluetooth Low Energy Tracker Hub](https://esphome.io/components/esp32_ble_tracker.html#esp32-bluetooth-low-energy-tracker-hub)*"
      },
      "esp32_camera": {
        "dependencies": [
          "esp32"
        ],
        "docs": "The `esp32_camera` component allows you to use ESP32-based camera boards in ESPHome that directly integrate into Home Assistant through the native API.\n\n*See also: [ESP32 Camera Component](https://esphome.io/components/esp32_camera.html#esp32-camera-component)*"
      },
      "esp32_camera_web_server": {
        "dependencies": [
          "esp32_camera"
        ],
        "docs": "The `esp32_camera_web_server` component allows you to use expose web server of ESP32-based camera boards in ESPHome that directly can be integrated into external surveillance or PVR software.\n\n*See also: [ESP32 Camera Web Server Component](https://esphome.io/components/esp32_camera_web_server.html#esp32-camera-web-server-component)*"
      },
      "esp32_improv": {
        "dependencies": [
          "wifi",
          "esp32"
        ],
        "docs": "The `esp32_improv` component in ESPHome implements the open [Improv standard](https://www.improv-wifi.com/) for configuring Wi-Fi on an ESP32 device by using Bluetooth Low Energy to receive the credentials.\n\n*See also: [Improv via BLE](https://esphome.io/components/esp32_improv.html#improv-via-ble)*"
      },
      "esp32_touch": {
        "dependencies": [
          "esp32"
        ],
        "docs": "The `esp32_touch` component creates a global hub enabling (capacitive) touch detection on GPIO pins [supported by ESP32, ESP32-S2 or ESP32-S3 processors](https://esphome.io/components/binary_sensor/esp32_touch.html#esp32-touch-pad-pins). With this enabled, [binary sensors](https://esphome.io/components/binary_sensor/esp32_touch.html#esp32-touch-binary-sensor) may then be configured to permit touch detection.\n\n*See also: [esp32_touch Component/Hub](https://esphome.io/components/binary_sensor/esp32_touch.html#component-hub)*"
      },
      "ethernet": {
        "dependencies": [
          "esp32"
        ],
        "docs": "This ESPHome component enables *wired* Ethernet connections for ESP32s.\n\n*See also: [Ethernet Component](https://esphome.io/components/ethernet.html#ethernet-component)*"
      },
      "exposure_notifications": {
        "dependencies": [
          "esp32_ble_tracker"
        ],
        "docs": "The `exposure_notifications` component uses the [ESP32 Bluetooth Low Energy Tracker Hub](https://esphome.io/components/esp32_ble_tracker.html) to discover nearby COVID-19 exposure notification bluetooth messages sent by phones running the [Google/Apple Exposure Notification service](https://www.google.com/covid19/exposurenotifications/).\n\n*See also: [Exposure Notification Listener](https://esphome.io/components/exposure_notifications.html#exposure-notification-listener)*"
      },
      "external_components": {
        "docs": "You can easily import community or personal components using the external components feature. Bundled components can be overridden using this feature.\n\n*See also: [External Components](https://esphome.io/components/external_components.html#external-components)*"
      },
      "ezo_pmp": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The `ezo_pmp` component allows you to use an Atlas Scientific Peristaltic Pump with ESPHome. Both the EZO-PMP ([datasheet](https://files.atlas-scientific.com/EZO_PMP_Datasheet.pdf)) and EZO-PMP-L ([datasheet](https://files.atlas-scientific.com/EZO_PMP_L_Datasheet.pdf)) are supported. The [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) is required to be set up in your configuration for this sensor to work.\n\n*See also: [Atlas Scientific Peristaltic Pump](https://esphome.io/components/ezo_pmp.html#atlas-scientific-peristaltic-pump)*"
      },
      "fingerprint_grow": {
        "dependencies": [
          "uart"
        ],
        "docs": "The reader can be powered by the 3.3V output of an NodeMCU. As the communication with the reader is done using UART (default baud rate is 57600), you need to have an [UART bus](https://esphome.io/components/uart.html#uart) in your configuration with the `rx_pin` connected to the reader\u2019s `TX` and the `tx_pin` connected to the reader\u2019s `RX`.\n\n*See also: [fingerprint_grow Component/Hub](https://esphome.io/components/fingerprint_grow.html#component-hub)*"
      },
      "font": {
        "dependencies": [
          "display"
        ],
        "docs": "The rendering engine also has a powerful font drawer which integrates seamlessly into ESPHome. Whereas in most Arduino display projects you have to use one of a few pre-defined fonts in very specific sizes, with ESPHome you have the option to use **any** TrueType (`.ttf`) font file at **any** size, as well as fixed-size [PCF](https://en.wikipedia.org/wiki/Portable_Compiled_Format) and [BDF](https://en.wikipedia.org/wiki/Glyph_Bitmap_Distribution_Format) bitmap fonts! Granted the reason for it is actually not having to worry about the licensing of font files :)\n\n*See also: [Fonts](https://esphome.io/components/display/index.html#fonts)*"
      },
      "globals": {
        "docs": "In some cases you might require to share a global variable across multiple lambdas. For example, global variables can be used to store the state of a garage door.\n\n*See also: [Global Variables](https://esphome.io/guides/automations.html#global-variables)*"
      },
      "gp8403": {
        "dependencies": [
          "i2c"
        ],
        "docs": "Configuration variables:\n\n*See also: [gp8403 Component/Hub](https://esphome.io/components/output/gp8403.html#component-hub)*"
      },
      "gps": {
        "dependencies": [
          "uart"
        ],
        "docs": "The `gps` component allows you to connect GPS modules to your ESPHome project. Any GPS module that uses the standardized NMEA communication protocol will work.\n\n*See also: [GPS Component](https://esphome.io/components/gps.html#gps-component)*"
      },
      "graph": {
        "dependencies": [
          "display",
          "sensor"
        ],
        "docs": "You can display a graph of a sensor value(s) using this component. The states used for the graph are stored in memory at the time the sensor updates and will be lost when the device reboots.\n\n*See also: [Graph Component](https://esphome.io/components/display/index.html#graph-component)*"
      },
      "grove_tb6612fng": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The Grove TBB6612FNG a runs over  I\u00b2C bus and has the capability to control DC and Stepper motors. At the current stage of implementation only DC motor is implemented.\n\n*See also: [Grove TB6612FNG Motor Drive](https://esphome.io/components/grove_tb6612fng.html#grove-tb6612fng-motor-drive)*"
      },
      "host": {},
      "http_request": {
        "dependencies": [
          "network"
        ],
        "docs": "The `http_request` component lets you make HTTP/HTTPS requests. First, you need to setup a component:\n\n*See also: [HTTP Request](https://esphome.io/components/http_request.html#http-request)*"
      },
      "i2c": {
        "docs": "This component sets up the I\u00b2C bus for your ESP32 or ESP8266. In order for these components to work correctly, you need to define the I\u00b2C bus in your configuration. Please note the ESP will enable its internal 10k\u2126 pullup resistors for these pins, so you usually don\u2019t need to put on external ones. You can use multiple devices on one I\u00b2C bus as each device is given a unique address for communicating between it and the ESP. You can do this by hopping wires from the two lines (SDA and SCL) from each device board to the next device board or by connecting the wires from each device back to the two I\u00b2C pins on the ESP.\n\n*See also: [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c-bus)*"
      },
      "i2s_audio": {
        "dependencies": [
          "esp32"
        ],
        "docs": "The `i2s_audio` component allows for sending and receiving audio via I\u00b2S. This component only works on ESP32 based chips.\n\n*See also: [I\u00b2S Audio Component](https://esphome.io/components/i2s_audio.html#i2s-audio-component)*"
      },
      "image": {
        "dependencies": [
          "display"
        ],
        "docs": "Use this component to store graphical images on the device, you can then draw the images on compatible displays.\n\n*See also: [Images](https://esphome.io/components/display/index.html#images)*"
      },
      "improv_serial": {
        "dependencies": [
          "logger",
          "wifi"
        ],
        "docs": "The `improv_serial` component in ESPHome implements the open [Improv standard](https://www.improv-wifi.com/) for configuring Wi-Fi on an ESPHome device by using a serial connection to the device, eg. USB.\n\n*See also: [Improv via Serial](https://esphome.io/components/improv_serial.html#improv-via-serial)*"
      },
      "interval": {
        "docs": "This component allows you to run actions at fixed time intervals. For example if you want to toggle a switch every minute, you can use this component. Please note that it\u2019s possible to achieve the same thing with the [time.on_time](https://esphome.io/components/time/index.html#time-on-time) trigger, but this technique is more light-weight and user-friendly.\n\n*See also: [interval Component](https://esphome.io/guides/automations.html#interval-component)*"
      },
      "json": {},
      "key_collector": {
        "docs": "The `key_collector` component collects key presses from components like [Matrix keypad](https://esphome.io/components/matrix_keypad.html#matrix-keypad) or `wiegand`. It allows you to process key sequences and treat them as one, for example to allow inputting of a PIN code or a passkey. The component outputs the result of the keypress sequence as a variable usable in automations.\n\n*See also: [Key collector component](https://esphome.io/components/key_collector.html#key-collector-component)*"
      },
      "lcd_menu": {
        "docs": "The component provides an infrastructure for setting up a hierarchical menu on character based LCD displays. This offers the user an interactive method to display labels, control entities like `switch`, `select`, `number`  available locally on the ESPHome node, without the requirement of a network connection.\n\n*See also: [LCD Menu](https://esphome.io/components/display_menu/lcd_menu.html#lcd-menu)*"
      },
      "ld2410": {
        "dependencies": [
          "uart"
        ],
        "docs": "The `ld2410` sensor platform allows you to use HI-LINK LD2410 motion and presence sensor ([datasheet and user manual](https://drive.google.com/drive/folders/1p4dhbEJA3YubyIjIIC7wwVsSo8x29Fq-?spm=a2g0o.detail.1000023.17.93465697yFwVxH)) with ESPHome.\n\n*See also: [ld2410 Component/Hub](https://esphome.io/components/sensor/ld2410.html#component-hub)*"
      },
      "libretiny": {},
      "lightwaverf": {
        "docs": "The `LightWaveRF` light platform creates a module to dump and send commands to light switches\n\n*See also: [LightWaveRF](https://esphome.io/components/lightwaverf.html#lightwaverf)*"
      },
      "logger": {
        "docs": "The logger component automatically logs all log messages through the serial port and through MQTT topics (if there is an MQTT client in the configuration). By default, all logs with a severity `DEBUG` or higher will be shown. Increasing the log level severity (to e.g `INFO` or `WARNING`) can help with the performance of the application and memory size.\n\n*See also: [Logger Component](https://esphome.io/components/logger.html#logger-component)*"
      },
      "matrix_keypad": {
        "docs": "The `matrix_keypad` component allows you to integrate pads which have the keys connected at the intersection points of the rows and columns of a matrix.\n\n*See also: [Matrix keypad](https://esphome.io/components/matrix_keypad.html#matrix-keypad)*"
      },
      "max6956": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The `max6956` is an [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) slave. Its address is configured using A0 and A1 hardware pins from 0x40 to 0x4F.\n\n*See also: [max6956 Component/Hub](https://esphome.io/components/max6956.html#component-hub)*"
      },
      "mcp23008": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The MCP23008 component ([datasheet](http://ww1.microchip.com/downloads/en/devicedoc/21919e.pdf), [Adafruit](https://www.adafruit.com/product/593)) has 8 GPIOs that can be configured independently.\n\n*See also: [MCP23008 Component](https://esphome.io/components/mcp230xx.html#mcp23008-component)*"
      },
      "mcp23016": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The MCP23016 component ([datasheet](http://ww1.microchip.com/downloads/en/devicedoc/20090c.pdf)) has 16 GPIOs and can be configured the same way than the other variants.\n\n*See also: [MCP23016 Component](https://esphome.io/components/mcp230xx.html#mcp23016-component)*"
      },
      "mcp23017": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The MCP23017 component allows you to use MCP23017 I/O expanders ([datasheet](http://ww1.microchip.com/downloads/en/devicedoc/20001952c.pdf), [Adafruit](https://www.adafruit.com/product/732)) in ESPHome. It uses the [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) for communication.\n\n*See also: [MCP23017 Component](https://esphome.io/components/mcp230xx.html#mcp23017-component)*"
      },
      "mcp23s08": {
        "dependencies": [
          "spi"
        ],
        "docs": "The MCP23S08 component ([datasheet](http://ww1.microchip.com/downloads/en/DeviceDoc/MCP23008-MCP23S08-Data-Sheet-20001919F.pdf), [Digi-Key](https://www.digikey.com/product-detail/en/microchip-technology/MCP23S08-E-P/MCP23S08-E-P-ND/735954)) has 8 GPIOs that can be configured independently.\n\n*See also: [MCP23S08 Component](https://esphome.io/components/mcp23Sxx.html#mcp23s08-component)*"
      },
      "mcp23s17": {
        "dependencies": [
          "spi"
        ],
        "docs": "The MCP23S17 component allows you to use MCP23S17 I/O expanders ([datasheet](http://ww1.microchip.com/downloads/en/DeviceDoc/20001952C.pdf), [Digi-Key](https://www.digikey.com/product-detail/en/microchip-technology/MCP23S17-E-SP/MCP23S17-E-SP-ND/894276)) in ESPHome. It uses the [SPI Bus](https://esphome.io/components/spi.html#spi) for communication.\n\n*See also: [MCP23S17 Component](https://esphome.io/components/mcp23Sxx.html#mcp23s17-component)*"
      },
      "mcp3008": {
        "dependencies": [
          "spi"
        ],
        "docs": "The MCP3008 component allows you to use MCP3008 8-Channel 10-Bit A/D Converter ([datasheet](http://ww1.microchip.com/downloads/en/DeviceDoc/21295d.pdf), [Adafruit](https://www.adafruit.com/product/856)) in ESPHome. It uses the [SPI Bus](https://esphome.io/components/spi.html#spi) for communication.\n\n*See also: [mcp3008 Component/Hub](https://esphome.io/components/sensor/mcp3008.html#component-hub)*"
      },
      "mcp3204": {
        "dependencies": [
          "spi"
        ],
        "docs": "The MCP3204 component allows you to use MCP3204 or MCP3208 12-Bit A/D Converter ([datasheet](https://ww1.microchip.com/downloads/en/DeviceDoc/21298e.pdf)) in ESPHome. The MCP3204 is a 4-channel and MCP3208 is an 8-channel device. It uses the [SPI Bus](https://esphome.io/components/spi.html#spi) for communication.\n\n*See also: [mcp3204 Component/Hub](https://esphome.io/components/sensor/mcp3204.html#component-hub)*"
      },
      "mcp4728": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The MCP4728 output component allows to use [12bit external quad DAC](https://www.adafruit.com/product/4470) in order to have analog outputs on any board by using [I\u00b2C](https://esphome.io/components/i2c.html#i2c). Devices default address is `0x60`.\n\n*See also: [MCP4728 Component](https://esphome.io/components/output/mcp4728.html#mcp4728-component)*"
      },
      "mdns": {
        "dependencies": [
          "network"
        ],
        "docs": "The `mdns` component makes the node announce itself on the local network using the multicast DNS (mDNS) protocol.\n\n*See also: [mDNS Component](https://esphome.io/components/mdns.html#mdns-component)*"
      },
      "modbus": {
        "dependencies": [
          "uart"
        ],
        "docs": "The Modbus protocol is used by many consumer and industrial devices for communication. This component allows components in ESPHome to communicate to those devices. Modbus requires a [UART Bus](https://esphome.io/components/uart.html#uart) to communicate.\n\n*See also: [Modbus Component](https://esphome.io/components/modbus.html#modbus-component)*"
      },
      "modbus_controller": {
        "docs": "The `modbus_controller` component creates a RS485 connection to control a modbus device\n\n*See also: [Modbus Controller](https://esphome.io/components/modbus_controller.html#modbus-controller)*"
      },
      "mopeka_ble": {
        "dependencies": [
          "esp32_ble_tracker"
        ]
      },
      "mpr121": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The `mpr121` sensor platform allows you to use your MPR121 ([datasheet](https://cdn-learn.adafruit.com/downloads/pdf/adafruit-mpr121-12-key-capacitive-touch-sensor-breakout-tutorial.pdf), [Adafruit](https://learn.adafruit.com/adafruit-mpr121-12-key-capacitive-touch-sensor-breakout-tutorial/overview)) Capacitive Touch Sensor with ESPHome. The [I\u00b2C](https://esphome.io/components/i2c.html#i2c) is required to be set up in your configuration for this sensor to work.\n\n*See also: [mpr121 Component/Hub](https://esphome.io/components/binary_sensor/mpr121.html#component-hub)*"
      },
      "mqtt": {
        "dependencies": [
          "network"
        ],
        "docs": "With the MQTT Message schema you can tell ESPHome how a specific MQTT message should be sent. It is used in several places like last will and birth messages or MQTT log options.\n\n*See also: [MQTTMessage](https://esphome.io/components/mqtt.html#mqttmessage)*"
      },
      "my9231": {
        "docs": "The MY9231/MY9291 component represents a MY9231/MY9291 LED driver chain ([MY9231 description](http://www.my-semi.com.tw/file/MY9231_BF_0.91.pdf), [MY9291 description](http://www.my-semi.com.tw/file/MY9291_BF_0.91.pdf)) in ESPHome. Communication is done with two GPIO pins (DI and DCKI) and multiple driver chips can be chained. There are two models with different number of output channels (MY9291 with 4 channels and MY9231 with 3 channels). They are popular driver chips used in smart light bulbs:\n\n*See also: [my9231 Component/Hub](https://esphome.io/components/output/my9231.html#component-hub)*"
      },
      "network": {
        "docs": "The network component is a global configuration for all types of networks (WiFi, Ethernet).\n\n*See also: [Network component](https://esphome.io/components/network.html#network-component)*"
      },
      "ota": {
        "dependencies": [
          "network"
        ],
        "docs": "With the OTA (Over The Air) update component you can upload your firmware binaries to your node without having to use a USB cable for uploads. ESPHome natively supports this through its `run` and `upload` helper scripts.\n\n*See also: [OTA Update Component](https://esphome.io/components/ota.html#ota-update-component)*"
      },
      "packages": {},
      "pca6416a": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The PCA6416A component allows you to use **PCA6416A** or **PCAL6416A** I/O expanders in ESPHome. It uses [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) for communication.\n\n*See also: [PCA6416A I/O Expander](https://esphome.io/components/pca6416a.html#pca6416a-i-o-expander)*"
      },
      "pca9554": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The PCA9554 component allows you to use **PCA9554**, **PCA9554A** or **PCA9536** I/O expanders in ESPHome. It uses [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) for communication.\n\n*See also: [PCA9554 I/O Expander](https://esphome.io/components/pca9554.html#pca9554-i-o-expander)*"
      },
      "pca9685": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The PCA9685 component represents a PCA9685 12-bit PWM driver ([datasheet](https://www.nxp.com/docs/en/data-sheet/PCA9685.pdf), [adafruit](https://www.adafruit.com/product/815)) in ESPHome. It uses [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) for communication.\n\n*See also: [pca9685 Component/Hub](https://esphome.io/components/output/pca9685.html#component-hub)*"
      },
      "pcf8574": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The PCF8574 component allows you to use PCF8574 or PCF8575 I/O expanders ([datasheet](http://www.ti.com/lit/ds/symlink/pcf8574.pdf), [SparkFun](https://www.sparkfun.com/products/retired/8130)) in ESPHome. It uses [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) for communication.\n\n*See also: [PCF8574 I/O Expander](https://esphome.io/components/pcf8574.html#pcf8574-i-o-expander)*"
      },
      "pipsolar": {
        "dependencies": [
          "uart"
        ],
        "docs": "The PipSolar component allows you to integrate PIP-compatible Inverters in ESPHome. It uses [UART](https://esphome.io/components/uart.html#uart) for communication.\n\n*See also: [PipSolar PV Inverter](https://esphome.io/components/pipsolar.html#pipsolar-pv-inverter)*"
      },
      "pn532": {},
      "pn532_i2c": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The `pn532` component allows you to use PN532 NFC/RFID controllers ([datasheet](https://cdn-shop.adafruit.com/datasheets/pn532ds.pdf), [Adafruit](https://www.adafruit.com/product/364)) with ESPHome. This component is a global hub that establishes the connection to the PN532 via [I\u00b2C](https://esphome.io/components/i2c.html#i2c) and outputs its data. Using the [PN532 binary sensors](https://esphome.io/components/binary_sensor/pn532.html#pn532-tag) you can then create individual binary sensors that track if an NFC/RFID tag is currently detected by the PN532.\n\n*See also: [pn532 Over I\u00b2C](https://esphome.io/components/binary_sensor/pn532.html#over-i2c)*"
      },
      "pn532_spi": {
        "dependencies": [
          "spi"
        ],
        "docs": "The `pn532_spi` component allows you to use PN532 NFC/RFID controllers ([datasheet](https://cdn-shop.adafruit.com/datasheets/pn532ds.pdf), [Adafruit](https://www.adafruit.com/product/364)) with ESPHome. This component is a global hub that establishes the connection to the PN532 via [SPI](https://esphome.io/components/spi.html#spi) and outputs its data. Using the [PN532 binary sensors](https://esphome.io/components/binary_sensor/pn532.html#pn532-tag) you can then create individual binary sensors that track if an NFC/RFID tag is currently detected by the PN532.\n\n*See also: [pn532 Over SPI](https://esphome.io/components/binary_sensor/pn532.html#over-spi)*"
      },
      "power_supply": {
        "docs": "The `power_supply` component allows you to have a high power mode for certain outputs. For example, if you\u2019re using an [ATX power supply](https://en.wikipedia.org/wiki/ATX) to power your LED strips, you usually don\u2019t want to have the power supply on all the time while the output is not on. The power supply component can be attached to any [Output Component](https://esphome.io/components/output/index.html#output) and will automatically switch on if any of the outputs are on. Furthermore, it also has a cooldown time that keeps the power supply on for a while after the last output has been disabled.\n\n*See also: [Power Supply Component](https://esphome.io/components/power_supply.html#power-supply-component)*"
      },
      "preferences": {},
      "prometheus": {
        "docs": "The `prometheus` component enables an HTTP endpoint for the [Web Server Component](https://esphome.io/components/web_server.html) in order to integrate a [Prometheus](https://prometheus.io/) installation.\n\n*See also: [Prometheus Component](https://esphome.io/components/prometheus.html#prometheus-component)*"
      },
      "psram": {
        "docs": "This component enables and configures PSRAM if/when available on ESP32 modules/boards. It is automatically loaded and enabled by components that require it.\n\n*See also: [PSRAM](https://esphome.io/components/psram.html#psram)*"
      },
      "qr_code": {
        "dependencies": [
          "display"
        ],
        "docs": "Use this component to generate a QR-code containing a string on the device, which can then be drawn on compatible displays.\n\n*See also: [QR Code Component](https://esphome.io/components/display/index.html#qr-code-component)*"
      },
      "radon_eye_ble": {
        "dependencies": [
          "esp32_ble_tracker"
        ]
      },
      "rc522_i2c": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The `rc522_i2c` component allows you to use RC522 NFC/RFID controllers with ESPHome. This component is a global hub that establishes the connection to the RC522 via [I\u00b2C](https://esphome.io/components/i2c.html#i2c) (also available over SPI). Using the [RC522 binary sensors](https://esphome.io/components/binary_sensor/rc522.html#rc522-binary-sensor) you can then create individual binary sensors that track if an NFC/RFID tag is currently detected by the RC522.\n\n*See also: [rc522 Over I\u00b2C](https://esphome.io/components/binary_sensor/rc522.html#over-i2c)*"
      },
      "rc522_spi": {
        "dependencies": [
          "spi"
        ],
        "docs": "The `rc522_spi` component allows you to use RC522 NFC/RFID controllers with ESPHome. This component is a global hub that establishes the connection to the RC522 via [SPI](https://esphome.io/components/spi.html#spi). Using [RC522 binary sensors](https://esphome.io/components/binary_sensor/rc522.html#rc522-binary-sensor), you can then create individual binary sensors that track if an NFC/RFID tag is currently detected by the RC522.\n\n*See also: [rc522 Over SPI](https://esphome.io/components/binary_sensor/rc522.html#over-spi)*"
      },
      "rdm6300": {
        "dependencies": [
          "uart"
        ],
        "docs": "The `rdm6300` component allows you to use RDM6300 NFC/RFID controllers ([datasheet](https://elty.pl/upload/download/RFID/RDM630-Spec.pdf), [iTead](https://www.itead.cc/rdm6300.html)) with ESPHome. This component is a global hub that establishes the connection to the RDM6300 via [UART](https://esphome.io/components/uart.html#uart) and translates the received data. Using the [RDM6300 binary sensors](https://esphome.io/components/binary_sensor/rdm6300.html#rdm6300-tag) you can then create individual binary sensors that track if an NFC/RFID tag is currently detected by the RDM6300.\n\n*See also: [rdm6300 Component/Hub](https://esphome.io/components/binary_sensor/rdm6300.html#component-hub)*"
      },
      "remote_receiver": {
        "docs": "The `remote_receiver` component lets you receive and decode any remote signal, these can for example be infrared remotes or 433MHz signals.\n\n*See also: [Remote Receiver](https://esphome.io/components/remote_receiver.html#remote-receiver)*"
      },
      "remote_transmitter": {
        "docs": "The `remote_transmitter` component lets you send digital packets to control devices in your home. For example this includes infrared data or 433MHz RF signals.\n\n*See also: [Remote Transmitter](https://esphome.io/components/remote_transmitter.html#remote-transmitter)*"
      },
      "rf_bridge": {
        "dependencies": [
          "uart"
        ],
        "docs": "The `RF Bridge` Component provides the ability to send and receive 433MHz remote codes using the embedded EFM8BB1 microcontroller. This component implements the communication protocol that the original `efm8bb1` firmware implements. The device is connected via the [UART bus](https://esphome.io/components/uart.html). The uart bus must be configured at the same speed of the module which is 19200bps.\n\n*See also: [RF Bridge Component](https://esphome.io/components/rf_bridge.html#rf-bridge-component)*"
      },
      "rp2040": {
        "docs": "This component contains platform-specific options for the RP2040 platform.\n\n*See also: [RP2040 Platform](https://esphome.io/components/rp2040.html#rp2040-platform)*"
      },
      "rtl87xx": {},
      "rtttl": {
        "docs": "The `rtttl`, component allows you to easily connect a passive piezo buzzer to your microcontroller and play monophonic songs. It accepts the Ring Tone Text Transfer Language, rtttl format ([Wikipedia](https://en.wikipedia.org/wiki/Ring_Tone_Transfer_Language)) which allows to store simple melodies.\n\n*See also: [Rtttl Buzzer](https://esphome.io/components/rtttl.html#rtttl-buzzer)*"
      },
      "ruuvi_ble": {
        "dependencies": [
          "esp32_ble_tracker"
        ]
      },
      "script": {
        "docs": "With the `script:` component you can define a list of steps in a central place, and then execute the script with a single call.\n\n*See also: [script Component](https://esphome.io/guides/automations.html#script-component)*"
      },
      "servo": {
        "docs": "The `servo` component allows you to use servo motors with ESPHome. Servos are motor controllers that contain all the electronics necessary for driving the motor and provide a simple PWM interface to control the motor.\n\n*See also: [Servo Component](https://esphome.io/components/servo.html#servo-component)*"
      },
      "sim800l": {
        "dependencies": [
          "uart"
        ],
        "docs": "The `SIM800L` Component provides the ability to dial, answer calls, send/receive SMS text messages and send/receive USSD codes. The device must be connected via a [UART bus](https://esphome.io/components/uart.html) supporting both receiving and transmitting line. The UART bus must be configured at the same speed of the module which is by default 9600bps. The required connection wires are `+VCC`, `GND`, `RX` and `TX`.\n\n*See also: [sim800l Component/Hub](https://esphome.io/components/sim800l.html#component-hub)*"
      },
      "sm16716": {
        "docs": "The SM16716 component represents a SM16716 LED driver chain ([SM16716 description](https://github.com/sowbug/sm16716/blob/master/SM16716%20Datasheet%20%5BChinese%5D.pdf), [SM16716 description](https://github.com/sowbug/sm16716/blob/master/SM16716%20Datasheet%20%5BChinese%5D.pdf)) in ESPHome. Communication is done with two GPIO pins (MOSI and SCLK) and multiple driver chips can be chained. It is used in some smart light bulbs:\n\n*See also: [sm16716 Component/Hub](https://esphome.io/components/output/sm16716.html#component-hub)*"
      },
      "sm2135": {
        "docs": "The SM2135 component represents a SM2135 LED driver chain ([SM2135 description](https://github.com/arendst/Sonoff-Tasmota/files/3656603/SM2135E_zh-CN_en-US_translated.pdf), [SM2135 description](https://github.com/arendst/Sonoff-Tasmota/files/3656603/SM2135E_zh-CN_en-US_translated.pdf)) in ESPHome. Communication is done with two GPIO pins (MOSI and SCLK). It is used in some smart light bulbs:\n\n*See also: [sm2135 Component/Hub](https://esphome.io/components/output/sm2135.html#component-hub)*"
      },
      "sm2235": {
        "docs": "The SM2235 component represents a SM2235 LED driver chain in ESPHome. Communication is done with two GPIO pins (DATA and CLK).\n\n*See also: [sm2235 Component/Hub](https://esphome.io/components/output/sm2235.html#component-hub)*"
      },
      "sm2335": {
        "docs": "The SM2335 component represents a SM2335 LED driver chain in ESPHome. Communication is done with two GPIO pins (DATA and CLK). It is used in some smart light bulbs:\n\n*See also: [sm2335 Component/Hub](https://esphome.io/components/output/sm2335.html#component-hub)*"
      },
      "sml": {
        "dependencies": [
          "uart"
        ],
        "docs": "The `SML` component connects to smart meters which use the *Smart Message Language* (SML) protocol.\n\n*See also: [SML (Smart Message Language)](https://esphome.io/components/sml.html#sml-smart-message-language)*"
      },
      "sn74hc165": {
        "docs": "The SN74HC165 component allows you to use SN74HC165 shift registers as I/O expanders (Input only, use SN74HC595 for outputs) ([datasheet](https://www.ti.com/lit/ds/symlink/sn74hc165.pdf)) in ESPHome. It uses 3 wires (optionally 4) for communication.\n\n*See also: [SN74HC165 I/O Expander (shift register)](https://esphome.io/components/sn74hc165.html#sn74hc165-i-o-expander-shift-register)*"
      },
      "sn74hc595": {
        "docs": "The SN74HC595 component allows you to use SN74HC595 shift registers as I/O expanders ([datasheet](http://www.ti.com/lit/ds/symlink/sn74hc595.pdf), [SparkFun](https://www.sparkfun.com/products/13699)) in ESPHome. It uses 3 wires (optionally 4) for communication.\n\n*See also: [SN74HC595 I/O Expander (shift register)](https://esphome.io/components/sn74hc595.html#sn74hc595-i-o-expander-shift-register)*"
      },
      "socket": {},
      "spi": {
        "docs": "SPI is a very common high-speed protocol for a lot of devices. The ESPHome SPI component implements only the host controller role, where it controls the bus, and writes or reads data from peripherals attached to the bus.\n\n*See also: [SPI Bus](https://esphome.io/components/spi.html#spi-bus)*"
      },
      "spi_device": {
        "dependencies": [
          "spi"
        ],
        "docs": "Other components that depend on the SPI component will reference it, typically to communicate with specific peripheral devices. There is also a general-purpose SPI device component that can be used to communicate with hardware not supported by a specific component. It allows selection of the SPI mode, data_rate, CS pin and bit order. Reads and writes on the device can be performed with lambdas. For example:\n\n*See also: [Generic SPI device component:](https://esphome.io/components/spi.html#generic-spi-device-component)*"
      },
      "sprinkler": {
        "docs": "The `sprinkler` controller component aims to behave like a sprinkler/irrigation valve controller, much like those made by companies such as Rain Bird or Hunter. It does so by automating control of a number of [switch](https://esphome.io/components/switch/index.html#config-switch) components, each of which would typically be used to control an individual electric valve via a relay or other switching device. It provides a number of features you\u2019d expect of a sprinkler controller, including:\n\n*See also: [Sprinkler Controller](https://esphome.io/components/sprinkler.html#sprinkler-controller)*"
      },
      "status_led": {
        "docs": "The `status_led` hooks into all ESPHome components and can indicate the status of the device. Specifically, it will:\n\n*See also: [Status LED](https://esphome.io/components/status_led.html#status-led)*"
      },
      "substitutions": {},
      "sun": {
        "docs": "The `sun` component allows you to track the sun\u2019s position in the sky. Calculations are done every 60 seconds.\n\n*See also: [Sun](https://esphome.io/components/sun.html#sun)*"
      },
      "sx1509": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The SX1509 component allows you to expand your I/O capabilities: ([datasheet](https://www.semtech.com/uploads/documents/sx1509_evk_users_guide.pdf), [SparkFun](https://learn.sparkfun.com/tutorials/sx1509-io-expander-breakout-hookup-guide/all)) in ESPHome. It uses [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) for communication.\n\n*See also: [SX1509 16 channel I/O Expander with LED driver and keypad engine](https://esphome.io/components/sx1509.html#sx1509-16-channel-i-o-expander-with-led-driver-and-keypad-engine)*"
      },
      "tca9548a": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The TCA9548A component allows you to use TCA9548A as a I\u00b2C multiplexer ([datasheet](https://www.ti.com/lit/ds/symlink/tca9548a.pdf), [AdaFruit](https://learn.adafruit.com/adafruit-tca9548a-1-to-8-i2c-multiplexer-breakout)) in ESPHome. It uses [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) for communication.\n\n*See also: [TCA9548A I\u00b2C Multiplexer](https://esphome.io/components/tca9548a.html#tca9548a-i2c-multiplexer)*"
      },
      "teleinfo": {
        "docs": "The `teleinfo` component allows you to retrieve data from a French electrical counter using Teleinformation ([datasheet](https://www.enedis.fr/sites/default/files/Enedis-NOI-CPT_54E.pdf)). It works with Linky electrical counter but also legacy EDF electrical counter.\n\n*See also: [teleinfo Component/Hub](https://esphome.io/components/sensor/teleinfo.html#component-hub)*"
      },
      "tlc59208f": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The TLC59208F component represents a Texas Instruments TLC59208F 8-bit PWM driver ([datasheet](http://www.ti.com/lit/gpn/tlc59208f), [hw example](https://faboplatform.github.io/ArduinoDocs/03.I2C%20Brick/211_brick_i2c_7seg/)) in ESPHome. It uses [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) for communication.\n\n*See also: [tlc59208f Component/Hub](https://esphome.io/components/output/tlc59208f.html#component-hub)*"
      },
      "tlc5947": {
        "docs": "This component represents a chain of [TLC5947 24-Channel, 12-Bit PWM LED Drivers](https://www.ti.com/lit/ds/symlink/tlc5947.pdf), which is used e.g. on this [board from Adafruit](https://www.adafruit.com/product/1429).\n\n*See also: [tlc5947 Component/Hub](https://esphome.io/components/output/tlc5947.html#component-hub)*"
      },
      "tm1651": {
        "docs": "The `tm1651` display platform allows you to use battery display units based on TM1651 chip, like [this one](https://aliexpress.com/item/32811491559.html) with ESPHome. Currently integration supports level and brightness setting. All updates can be made via lambda expressions.\n\n*See also: [TM1651 Battery Display](https://esphome.io/components/tm1651.html#tm1651-battery-display)*"
      },
      "ttp229_bsf": {
        "docs": "The configuration is made up of two parts: The central component, and individual Binary sensors per channel.\n\n*See also: [ttp229_bsf Component](https://esphome.io/components/binary_sensor/ttp229.html#ttp229-bsf-component)*"
      },
      "ttp229_lsf": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The configuration is made up of two parts: The central component, and individual Binary sensors per channel.\n\n*See also: [ttp229_lsf Component](https://esphome.io/components/binary_sensor/ttp229.html#ttp229-lsf-component)*"
      },
      "tuya": {
        "dependencies": [
          "uart"
        ],
        "docs": "The `tuya` component creates a serial connection to the Tuya MCU for platforms to use.\n\n*See also: [Tuya MCU](https://esphome.io/components/tuya.html#tuya-mcu)*"
      },
      "uart": {
        "docs": "UART is a common serial protocol for a lot of devices. For example, when uploading a binary to your ESP you have probably used UART to access the chip. UART (or for Arduino often also called Serial) usually consists of 2 pins:\n\n*See also: [UART Bus](https://esphome.io/components/uart.html#uart-bus)*"
      },
      "vbus": {
        "dependencies": [
          "uart"
        ],
        "docs": "The `VBus` Component provides status reading connectivity to solar heat energy collector controllers using VBus protocol. These devices are mainly produced by Resol, often also found under different brand names like Viessmann, Kioto, Wagner etc. The component currently supports natively the models in the table below but any device can be added via lambda by knowing [its packet structure](https://danielwippermann.github.io/resol-vbus).\n\n*See also: [VBus Component](https://esphome.io/components/vbus.html#vbus-component)*"
      },
      "voice_assistant": {
        "dependencies": [
          "api",
          "microphone"
        ],
        "docs": "ESPHome devices with a microphone are able to stream the audio to Home Assistant and be processed there by [assist](https://www.home-assistant.io/voice_control/).\n\n*See also: [Voice Assistant](https://esphome.io/components/voice_assistant.html#voice-assistant)*"
      },
      "web_server": {
        "docs": "The `web_server` component creates a simple web server on the node that can be accessed through any browser and a simple [REST API](https://esphome.io/web-api/index.html#api-rest). Please note that enabling this component will take up *a lot* of memory and may decrease stability, especially on ESP8266.\n\n*See also: [Web Server Component](https://esphome.io/components/web_server.html#web-server-component)*"
      },
      "web_server_base": {
        "dependencies": [
          "network"
        ]
      },
      "web_server_idf": {},
      "wiegand": {
        "docs": "The `wiegand` component allows you to integrate Wiegand-standard key input and card or tag reader panels in Home Assistant.\n\n*See also: [Wiegand keypad and tag reader](https://esphome.io/components/wiegand.html#wiegand-keypad-and-tag-reader)*"
      },
      "wifi": {
        "docs": "WPA2_EAP Enterprise Authentication is supported on ESP32s and ESP8266s. In order to configure this feature you must use the [Connecting to Multiple Networks](https://esphome.io/components/wifi.html#wifi-networks) style configuration. The ESP32 is known to work with PEAP, EAP-TTLS, and the certificate based EAP-TLS. These are advanced settings and you will usually need to consult your enterprise network administrator.\n\n*See also: [Enterprise Authentication](https://esphome.io/components/wifi.html#enterprise-authentication)*"
      },
      "wireguard": {
        "dependencies": [
          "time",
          "esp32"
        ],
        "docs": "[WireGuard\u00ae](https://www.wireguard.org/) is an extremely simple yet fast and modern VPN that utilizes state-of-the-art cryptography. This component uses a **custom** implementation not developed by original authors and currently available for **ESP32 platform only**.\n\n*See also: [WireGuard Component](https://esphome.io/components/wireguard.html#wireguard-component)*"
      },
      "wled": {},
      "xiaomi_ble": {
        "dependencies": [
          "esp32_ble_tracker"
        ]
      },
      "xiaomi_rtcgq02lm": {
        "dependencies": [
          "esp32_ble_tracker"
        ]
      },
      "xl9535": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The XL9535 component allows you to use **XL9535** I/O expander in ESPHome. It uses [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) for communication.\n\n*See also: [XL9535 I/O Expander](https://esphome.io/components/xl9535.html#xl9535-i-o-expander)*"
      },
      "xpt2046": {}
    },
    "action": {
      "delay": {
        "templatable": true,
        "type": "schema",
        "schema": {
          "extends": [
            "core.positive_time_period_milliseconds"
          ]
        },
        "docs": "This action delays the execution of the next action in the action list by a specified time period.\n\n*See also: [`delay` Action](https://esphome.io/guides/automations.html#delay-action)*"
      },
      "if": {
        "type": "schema",
        "schema": {
          "config_vars": {
            "condition": {
              "key": "Required",
              "type": "registry",
              "registry": "condition",
              "docs": "**[All Conditions](https://esphome.io/guides/automations.html#config-condition)**: The condition to check which branch to take. See [Conditions](https://esphome.io/guides/automations.html#config-condition).\n\n*See also: [Global Variables](https://esphome.io/guides/automations.html#if-action)*"
            },
            "then": {
              "key": "Optional",
              "is_list": true,
              "type": "registry",
              "registry": "action",
              "docs": "**[Action](https://esphome.io/guides/automations.html#config-action)**: The action to perform if the condition evaluates to true. Defaults to doing nothing.\n\n*See also: [Global Variables](https://esphome.io/guides/automations.html#if-action)*"
            },
            "else": {
              "key": "Optional",
              "is_list": true,
              "type": "registry",
              "registry": "action",
              "docs": "**[Action](https://esphome.io/guides/automations.html#config-action)**: The action to perform if the condition evaluates to false. Defaults to doing nothing.\n\n*See also: [Global Variables](https://esphome.io/guides/automations.html#if-action)*"
            }
          }
        },
        "docs": "This action first evaluated a certain condition (`if:`) and then either executes the `then:` branch or the `else:` branch depending on the output of the condition.\n\n*See also: [`if` Action](https://esphome.io/guides/automations.html#if-action)*"
      },
      "while": {
        "type": "schema",
        "schema": {
          "config_vars": {
            "condition": {
              "key": "Required",
              "type": "registry",
              "registry": "condition",
              "docs": "The condition to check whether to execute. See [Conditions](https://esphome.io/guides/automations.html#config-condition).\n\n*See also: [Global Variables](https://esphome.io/guides/automations.html#while-action)*"
            },
            "then": {
              "key": "Required",
              "is_list": true,
              "type": "registry",
              "registry": "action",
              "docs": "**[Action](https://esphome.io/guides/automations.html#config-action)**: The action to perform until the condition evaluates to false.\n\n*See also: [Global Variables](https://esphome.io/guides/automations.html#while-action)*"
            }
          }
        },
        "docs": "This action is similar to the [if](https://esphome.io/guides/automations.html#if-action) Action. The `while` action executes a block until a given condition evaluates to false.\n\n*See also: [`while` Action](https://esphome.io/guides/automations.html#while-action)*"
      },
      "repeat": {
        "type": "schema",
        "schema": {
          "config_vars": {
            "count": {
              "key": "Required",
              "templatable": true,
              "type": "integer",
              "data_type": "positive_not_null_int",
              "docs": "**int**: The number of times the action should be repeated.\n\n*See also: [Global Variables](https://esphome.io/guides/automations.html#repeat-action)*"
            },
            "then": {
              "key": "Required",
              "is_list": true,
              "type": "registry",
              "registry": "action",
              "docs": "**[Action](https://esphome.io/guides/automations.html#config-action)**: The action to repeat.\n\n*See also: [Global Variables](https://esphome.io/guides/automations.html#repeat-action)*"
            }
          }
        },
        "docs": "This action allows you to repeat a block a given number of times. For example, the automation below will flash the light five times.\n\n*See also: [`repeat` Action](https://esphome.io/guides/automations.html#repeat-action)*"
      },
      "wait_until": {
        "type": "schema",
        "maybe": "condition",
        "schema": {
          "config_vars": {
            "condition": {
              "key": "Required",
              "type": "registry",
              "registry": "condition",
              "docs": "The condition to wait to become true. See [Conditions](https://esphome.io/guides/automations.html#config-condition).\n\n*See also: [Global Variables](https://esphome.io/guides/automations.html#wait-until-action)*"
            },
            "timeout": {
              "key": "Optional",
              "templatable": true,
              "type": "schema",
              "schema": {
                "extends": [
                  "core.positive_time_period_milliseconds"
                ]
              },
              "docs": "**[Time](https://esphome.io/guides/configuration-types.html#config-time)**: Time to wait before timing out. Defaults to never timing out.\n\n*See also: [Global Variables](https://esphome.io/guides/automations.html#wait-until-action)*"
            }
          }
        },
        "docs": "This action allows your automations to wait until a condition evaluates to true. (So this is just a shorthand way of writing a `while` action with an empty `then` block.)\n\n*See also: [`wait_until` Action](https://esphome.io/guides/automations.html#wait-until-action)*"
      },
      "lambda": {
        "docs": "This action executes an arbitrary piece of C++ code (see [Lambda](https://esphome.io/guides/automations.html#config-lambda)).\n\n*See also: [`lambda` Action](https://esphome.io/guides/automations.html#lambda-action)*"
      }
    },
    "condition": {
      "and": {
        "is_list": true,
        "type": "registry",
        "registry": "condition"
      },
      "or": {
        "is_list": true,
        "type": "registry",
        "registry": "condition"
      },
      "not": {
        "type": "registry",
        "registry": "condition"
      },
      "lambda": {
        "docs": "This condition performs an arbitrary piece of C++ code (see [Lambda](https://esphome.io/guides/automations.html#config-lambda)) and can be used to create conditional flow in actions.\n\n*See also: [`lambda` Condition](https://esphome.io/guides/automations.html#lambda-condition)*"
      },
      "for": {
        "type": "schema",
        "schema": {
          "config_vars": {
            "time": {
              "key": "Required",
              "templatable": true,
              "type": "schema",
              "schema": {
                "extends": [
                  "core.positive_time_period_milliseconds"
                ]
              },
              "docs": "**[templatable](https://esphome.io/guides/automations.html#config-templatable), [Time](https://esphome.io/guides/configuration-types.html#config-time)**: The time for which the condition has to have been true.\n\n*See also: [script Component](https://esphome.io/guides/automations.html#for-condition)*"
            },
            "condition": {
              "key": "Required",
              "type": "registry",
              "registry": "condition",
              "docs": "**[Condition](https://esphome.io/guides/automations.html#config-condition)**: The condition to check.\n\n*See also: [script Component](https://esphome.io/guides/automations.html#for-condition)*"
            }
          },
          "extends": [
            "core.COMPONENT_SCHEMA"
          ]
        },
        "docs": "This [Condition](https://esphome.io/guides/automations.html#config-condition) allows you to check if a given condition has been true for at least a given amount of time.\n\n*See also: [`for` Condition](https://esphome.io/guides/automations.html#for-condition)*"
      }
    },
    "pins": [
      "esp32",
      "esp8266",
      "bk72xx",
      "host",
      "max6956",
      "mcp23xxx",
      "mcp23016",
      "pca6416a",
      "pca9554",
      "pcf8574",
      "rp2040",
      "rtl87xx",
      "sn74hc165",
      "sn74hc595",
      "sx1509",
      "xl9535"
    ]
  }
}