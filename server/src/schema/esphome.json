{
  "esphome": {
    "schemas": {
      "CONFIG_SCHEMA": {
        "type": "schema",
        "schema": {
          "config_vars": {
            "name": {
              "key": "Required",
              "type": "string",
              "docs": "**string**: This is the name of the node. It should always be unique in your ESPHome network. May only contain lowercase characters, digits and hyphens, and can be at most 24 characters long by default, or 31 characters long if `name_add_mac_suffix` is `false`. See [Changing ESPHome Node Name](https://esphome.io/components/esphome.html#esphome-changing-node-name).\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
            },
            "friendly_name": {
              "key": "Optional",
              "default": "",
              "type": "string",
              "docs": "**string**: This is the name sent to the frontend. It is used by Home Assistant as the integration name, device name, and is automatically prefixed to entities where necessary.\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
            },
            "area": {
              "key": "Optional",
              "default": "",
              "type": "string",
              "docs": "**string**: This is the area sent to the frontend. It is used by Home Assistant as the area / zone which the node belongs to.\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#configuration-variables)*"
            },
            "comment": {
              "key": "Optional",
              "type": "string"
            },
            "build_path": {
              "key": "Required",
              "type": "string"
            },
            "platformio_options": {
              "key": "String",
              "default": "{}",
              "key_type": "string_strict",
              "type": "schema",
              "schema": {
                "config_vars": {
                  "string": {
                    "type": "string"
                  }
                }
              }
            },
            "on_boot": {
              "key": "Optional",
              "type": "trigger",
              "schema": {
                "config_vars": {
                  "priority": {
                    "key": "Optional",
                    "default": "600.0"
                  },
                  "then": {
                    "type": "trigger"
                  }
                }
              }
            },
            "on_shutdown": {
              "key": "Optional",
              "type": "trigger",
              "schema": {
                "config_vars": {
                  "priority": {
                    "key": "Optional",
                    "default": "600.0"
                  },
                  "then": {
                    "type": "trigger"
                  }
                }
              }
            },
            "on_loop": {
              "key": "Optional",
              "type": "trigger"
            },
            "includes": {
              "key": "Optional",
              "default": "[]",
              "is_list": true
            },
            "libraries": {
              "key": "Optional",
              "default": "[]",
              "is_list": true,
              "type": "string"
            },
            "name_add_mac_suffix": {
              "key": "Optional",
              "default": "False",
              "type": "boolean"
            },
            "debug_scheduler": {
              "key": "Optional",
              "default": "False",
              "type": "boolean"
            },
            "project": {
              "key": "Optional",
              "type": "schema",
              "schema": {
                "config_vars": {
                  "name": {
                    "key": "Required",
                    "type": "string"
                  },
                  "version": {
                    "key": "Required",
                    "type": "string"
                  },
                  "on_update": {
                    "key": "Optional",
                    "type": "trigger"
                  }
                }
              }
            },
            "min_version": {
              "key": "Optional",
              "default": "2025.5.0-dev"
            },
            "compile_process_limit": {
              "key": "Optional",
              "type": "integer"
            }
          }
        }
      }
    }
  },
  "esphome.ota": {
    "schemas": {
      "CONFIG_SCHEMA": {
        "type": "schema",
        "schema": {
          "config_vars": {
            "id": {
              "key": "GeneratedID",
              "id_type": {
                "class": "esphome::ESPHomeOTAComponent",
                "parents": [
                  "ota::OTAComponent",
                  "Component"
                ]
              },
              "docs": "**[ID](https://esphome.io/guides/configuration-types.html#config-id)**: Manually specify the ID used for code generation.\n\n*See also: [ESPHome OTA Updates](https://esphome.io/components/ota/esphome.html#configuration-variables)*"
            },
            "version": {
              "key": "Optional",
              "default": "2",
              "type": "enum",
              "values": {
                "1": null,
                "2": null
              },
              "docs": "**int**: Version of OTA protocol to use. Version 2 is more stable. To downgrade to legacy ESPHome, the device should be updated with OTA version 1 first. Defaults to `2`.\n\n*See also: [ESPHome OTA Updates](https://esphome.io/components/ota/esphome.html#configuration-variables)*"
            },
            "port": {
              "key": "Optional",
              "default": "8266",
              "type": "integer",
              "data_type": "port",
              "docs": "**int**: The port to use for OTA updates. Defaults:\n  * `3232` for the ESP32\n  \n  * `8266` for the ESP8266\n  \n  * `2040` for the RP2040\n  \n  * `8892` for Beken chips\n  \n  \n\n*See also: [ESPHome OTA Updates](https://esphome.io/components/ota/esphome.html#configuration-variables)*"
            },
            "password": {
              "key": "Optional",
              "type": "string",
              "docs": "**string**: The password to use for updates.\n\n*See also: [ESPHome OTA Updates](https://esphome.io/components/ota/esphome.html#configuration-variables)*"
            }
          },
          "extends": [
            "ota.BASE_OTA_SCHEMA",
            "core.COMPONENT_SCHEMA"
          ]
        }
      }
    }
  },
  "core": {
    "schemas": {
      "time_period_dict": {
        "type": "schema",
        "schema": {
          "config_vars": {
            "days": {
              "key": "Optional"
            },
            "hours": {
              "key": "Optional"
            },
            "minutes": {
              "key": "Optional"
            },
            "seconds": {
              "key": "Optional"
            },
            "milliseconds": {
              "key": "Optional"
            },
            "microseconds": {
              "key": "Optional"
            }
          }
        }
      },
      "positive_time_period_milliseconds": {
        "type": "schema",
        "schema": {
          "extends": [
            "core.time_period_dict"
          ]
        }
      },
      "positive_time_period_seconds": {
        "type": "schema",
        "schema": {
          "extends": [
            "core.time_period_dict"
          ]
        }
      },
      "positive_time_period_minutes": {
        "type": "schema",
        "schema": {
          "extends": [
            "core.time_period_dict"
          ]
        }
      },
      "positive_time_period_microseconds": {
        "type": "schema",
        "schema": {
          "extends": [
            "core.time_period_dict"
          ]
        }
      },
      "positive_time_period_nanoseconds": {
        "type": "schema",
        "schema": {
          "extends": [
            "core.time_period_dict"
          ]
        }
      },
      "MQTT_COMPONENT_SCHEMA": {
        "type": "schema",
        "schema": {
          "config_vars": {
            "qos": {
              "key": "Optional",
              "docs": "**int**: The [Quality of Service]([https://www.hivemq.com/blog/mqtt-essentials-part-6-mqtt-quality-of-service-levels/](https://www.hivemq.com/blog/mqtt-essentials-part-6-mqtt-quality-of-service-levels/)) level for publishing. Defaults to 0.\n\n*See also: [MQTT Component Base Configuration](https://esphome.io/components/mqtt.html#mqtt-component-base-configuration)*"
            },
            "retain": {
              "key": "Optional",
              "type": "boolean",
              "docs": "**boolean**: If all MQTT state messages should be retained. Defaults to `true`.\n\n*See also: [MQTT Component Base Configuration](https://esphome.io/components/mqtt.html#mqtt-component-base-configuration)*"
            },
            "discovery": {
              "key": "Optional",
              "type": "boolean",
              "docs": "**boolean**: Manually enable/disable discovery for a component. Defaults to the global default.\n\n*See also: [MQTT Component Base Configuration](https://esphome.io/components/mqtt.html#mqtt-component-base-configuration)*"
            },
            "subscribe_qos": {
              "key": "Optional",
              "docs": "**int**: The [Quality of Service]([https://www.hivemq.com/blog/mqtt-essentials-part-6-mqtt-quality-of-service-levels/](https://www.hivemq.com/blog/mqtt-essentials-part-6-mqtt-quality-of-service-levels/)) level advertised in discovery for subscribing (only if discovery is enabled). Defaults to 0.\n\n*See also: [MQTT Component Base Configuration](https://esphome.io/components/mqtt.html#mqtt-component-base-configuration)*"
            },
            "state_topic": {
              "key": "Optional",
              "docs": "**string**: The topic to publish state updates to. Defaults to `<TOPIC_PREFIX>/<COMPONENT_TYPE>/<COMPONENT_NAME>/state`.ESPHome will always publish a manually configured state topic, even if the component is internal. Use `null` to disable publishing the component\u2019s state.\n\n*See also: [MQTT Component Base Configuration](https://esphome.io/components/mqtt.html#mqtt-component-base-configuration)*"
            },
            "availability": {
              "key": "Optional",
              "type": "schema",
              "schema": {
                "config_vars": {
                  "topic": {
                    "key": "Required"
                  },
                  "payload_available": {
                    "key": "Optional",
                    "default": "online"
                  },
                  "payload_not_available": {
                    "key": "Optional",
                    "default": "offline"
                  }
                }
              },
              "docs": "Manually set what should be sent to Home Assistant for showing entity availability. Default derived from [global birth/last will message](https://esphome.io/components/mqtt.html#mqtt-last-will-birth).\n\n*See also: [MQTT Component Base Configuration](https://esphome.io/components/mqtt.html#mqtt-component-base-configuration)*"
            }
          }
        }
      },
      "COMPONENT_SCHEMA": {
        "type": "schema",
        "schema": {
          "config_vars": {
            "setup_priority": {
              "key": "Optional"
            }
          }
        }
      },
      "MQTT_COMMAND_COMPONENT_SCHEMA": {
        "type": "schema",
        "schema": {
          "extends": [
            "core.MQTT_COMPONENT_SCHEMA"
          ],
          "config_vars": {
            "command_topic": {
              "key": "Optional",
              "docs": "**string**: The topic to subscribe to for commands from the remote. Defaults to `<TOPIC_PREFIX>/<COMPONENT_TYPE>/<COMPONENT_NAME>/command`.ESPHome will always subscribe to a manually configured command topic, even if the component is internal. Use `null` to disable subscribing to the component\u2019s command topic.\n\n*See also: [MQTT Component Base Configuration](https://esphome.io/components/mqtt.html#mqtt-component-base-configuration)*"
            },
            "command_retain": {
              "key": "Optional",
              "type": "boolean",
              "docs": "**boolean**: Whether MQTT command messages sent to the device should be retained or not. Default to `false`.\n\n*See also: [MQTT Component Base Configuration](https://esphome.io/components/mqtt.html#mqtt-component-base-configuration)*"
            },
            "name": {
              "docs": "**string**: The name to use for the MQTT Component.\n\n*See also: [MQTT Component Base Configuration](https://esphome.io/components/mqtt.html#mqtt-component-base-configuration)*"
            }
          }
        }
      },
      "ENTITY_BASE_SCHEMA": {
        "type": "schema",
        "schema": {
          "config_vars": {
            "name": {
              "key": "Optional",
              "docs": "**string**: The name for the valve. At least one of **id** and **name** must be specified.\n   > If you have a [friendly_name](https://esphome.io/components/esphome.html#esphome-configuration-variables) set for your device and you want the valve to use that name, you can set `name: None`.\n\n*See also: [Valve Component](https://esphome.io/components/valve/index.html#base-valve-configuration)*"
            },
            "internal": {
              "key": "Optional",
              "type": "boolean",
              "docs": "**boolean**: Mark this component as internal. Internal components will not be exposed to the frontend (like Home Assistant). Only specifying an `id` without a `name` will implicitly set this to true.\n\n*See also: [Valve Component](https://esphome.io/components/valve/index.html#base-valve-configuration)*"
            },
            "disabled_by_default": {
              "key": "Optional",
              "default": "False",
              "type": "boolean",
              "docs": "**boolean**: If true, this entity should not be added to any client\u2019s frontend, (usually Home Assistant) without the user manually enabling it (via the Home Assistant UI). Defaults to `false`.\n\n*See also: [Valve Component](https://esphome.io/components/valve/index.html#base-valve-configuration)*"
            },
            "icon": {
              "key": "Optional",
              "docs": "**icon**: Manually set the icon to use for the valve in the frontend.\n\n*See also: [Valve Component](https://esphome.io/components/valve/index.html#base-valve-configuration)*"
            },
            "entity_category": {
              "key": "Optional",
              "docs": "**string**: The category of the entity. See [https://developers.home-assistant.io/docs/core/entity/#generic-properties](https://developers.home-assistant.io/docs/core/entity/#generic-properties) for a list of available options. Set to `\"\"` to remove the default entity category.\n\n*See also: [Valve Component](https://esphome.io/components/valve/index.html#base-valve-configuration)*"
            }
          }
        }
      },
      "GIT_SCHEMA": {
        "type": "schema",
        "schema": {
          "config_vars": {
            "url": {
              "key": "Required"
            },
            "ref": {
              "key": "Optional"
            },
            "username": {
              "key": "Optional",
              "type": "string"
            },
            "password": {
              "key": "Optional",
              "type": "string"
            },
            "path": {
              "key": "Optional",
              "type": "string"
            }
          }
        }
      },
      "SOURCE_SCHEMA": {
        "type": "typed",
        "types": {
          "git": {
            "extends": [
              "core.GIT_SCHEMA"
            ]
          },
          "local": {
            "config_vars": {
              "path": {
                "key": "Required"
              }
            }
          }
        },
        "typed_key": "type",
        "docs": "Repository type. One of `local`, `git`.\n\n*See also: [External Components](https://esphome.io/components/external_components.html#external-components)*"
      }
    },
    "platforms": {
      "sensor": {
        "docs": "ESPHome has support for many different sensors. Each of them is a platform of the `sensor` domain and each sensor has several base configuration options.\n\n*See also: [Sensor Component](https://esphome.io/components/sensor/index.html#sensor-component)*"
      },
      "alarm_control_panel": {
        "docs": "Configuration variables:\n\n*See also: [Alarm Control Panel Component](https://esphome.io/components/alarm_control_panel/index.html#alarm-control-panel-component)*"
      },
      "audio_adc": {},
      "audio_dac": {},
      "binary_sensor": {
        "docs": "With ESPHome you can use different types of binary sensors. They will automatically appear in the Home Assistant front-end and have several configuration options.\n\n*See also: [Binary Sensor Component](https://esphome.io/components/binary_sensor/index.html#binary-sensor-component)*"
      },
      "button": {
        "docs": "To attach a physical button to ESPHome, see [GPIO Binary Sensor](https://esphome.io/components/binary_sensor/gpio.html).\n\n*See also: [Button Component](https://esphome.io/components/button/index.html#button-component)*"
      },
      "canbus": {
        "docs": "The Controller Area Network (CAN) bus is a serial bus protocol to connect individual systems and sensors as an alternative to conventional multi-wire looms. It allows automotive components to communicate on a single or dual-wire data bus at speeds up to 1Mbps.\n\n*See also: [CAN Bus](https://esphome.io/components/canbus/index.html#can-bus)*"
      },
      "climate": {
        "docs": "ESPHome has support for climate devices. Climate devices can represent different types of hardware, but the defining factor is that climate devices have a settable target temperature and can be put in different modes like `HEAT`, `COOL`, `HEAT_COOL` or `OFF`.\n\n*See also: [Climate Component](https://esphome.io/components/climate/index.html#climate-component)*"
      },
      "cover": {
        "docs": "The `cover` component is a generic representation of covers in ESPHome. A cover can (currently) either be *closed* or *open* and supports three types of commands: *open*, *close* and *stop*.\n\n*See also: [Cover Component](https://esphome.io/components/cover/index.html#cover-component)*"
      },
      "datetime": {},
      "display": {},
      "event": {
        "docs": "ESPHome supports the creation of event entities in Home Assistant. These entities allow for the triggering of custom events within the Home Assistant ecosystem, enabling complex automations and integrations. An event entity is represented as a stateless entity associated with a device that has a pre-defined set of event types which can be triggered in Home Assistant via automations.\n\n*See also: [Event Component](https://esphome.io/components/event/index.html#event-component)*"
      },
      "fan": {
        "docs": "With the `fan` domain you can create components that appear as fans in the Home Assistant frontend. A fan can be switched on or off, optionally has a speed between 1 and the maximum supported speed of the fan, and can have an oscillation and direction output.\n\n*See also: [Fan Component](https://esphome.io/components/fan/index.html#fan-component)*"
      },
      "light": {
        "docs": "In ESPHome, `light` components allow you to create lights usable from Home Assistant\u2019s frontend and have many features such as colors, transitions and even effects.\n\n*See also: [Light Component](https://esphome.io/components/light/index.html#light-component)*"
      },
      "lock": {
        "docs": "The `lock` domain includes all platforms that should function like a lock with lock/unlock actions.\n\n*See also: [Lock Component](https://esphome.io/components/lock/index.html#lock-component)*"
      },
      "media_player": {
        "docs": "The `media_player` domain includes all platforms that implement media player functionality.\n\n*See also: [Media Player Components](https://esphome.io/components/media_player/index.html#media-player-components)*"
      },
      "microphone": {
        "docs": "The `microphone` domain contains common functionality shared across the microphone platforms.\n\n*See also: [Microphone Components](https://esphome.io/components/microphone/index.html#microphone-components)*"
      },
      "number": {
        "docs": "ESPHome has support for components to create a number entity. A number entity is like a sensor that can read a value from a device, but is useful when that value can be set by the user/frontend.\n\n*See also: [Number Component](https://esphome.io/components/number/index.html#number-component)*"
      },
      "one_wire": {},
      "ota": {},
      "output": {
        "docs": "Each output platform extends this configuration schema.\n\n*See also: [Base Output Configuration](https://esphome.io/components/output/index.html#base-output-configuration)*"
      },
      "select": {
        "docs": "ESPHome has support for components to create a select entity. A select entity is basically an option list that can be set by either yaml, hardware or the user/frontend.\n\n*See also: [Select Component](https://esphome.io/components/select/index.html#select-component)*"
      },
      "speaker": {
        "docs": "The `speaker` domain contains common functionality shared across the speaker platforms.\n\n*See also: [Speaker Components](https://esphome.io/components/speaker/index.html#speaker-components)*"
      },
      "stepper": {
        "docs": "The `stepper` component allows you to use stepper motors with ESPHome. Currently only the A4988 stepper driver ([datasheet](https://www.pololu.com/file/0J450/a4988_DMOS_microstepping_driver_with_translator.pdf)) and ULN2003 ([datasheet](http://www.ti.com/lit/ds/symlink/uln2003a.pdf)) are supported.\n\n*See also: [Stepper Component](https://esphome.io/components/stepper/index.html#stepper-component)*"
      },
      "switch": {
        "docs": "The `switch` domain includes all platforms that should show up like a switch and can only be turned ON or OFF.\n\n*See also: [Switch Component](https://esphome.io/components/switch/index.html#switch-component)*"
      },
      "text": {
        "docs": "ESPHome has support for components to create a text entity. A text entity is like a `text_sensor` that can read a value from a device, but is useful when that value can be set by the user/frontend.\n\n*See also: [Text Component](https://esphome.io/components/text/index.html#text-component)*"
      },
      "text_sensor": {
        "docs": "Text sensors are a lot like normal [sensors](https://esphome.io/components/sensor/index.html). But where the \u201cnormal\u201d sensors only represent sensors that output **numbers**, this component can represent any *text*.\n\n*See also: [Text Sensor Component](https://esphome.io/components/text_sensor/index.html#text-sensor-component)*"
      },
      "time": {
        "docs": "The `time` component allows you to set up real time clock time sources for ESPHome. You can then get the current time in [lambdas](https://esphome.io/automations/templates.html#config-lambda).\n\n*See also: [Time Component](https://esphome.io/components/time/index.html#time-component)*"
      },
      "touchscreen": {
        "docs": "The `touchscreen` component contains the base code for most touchscreen driver components available in ESPHome and is responsible for passing the touch events to `binary_sensors` with the `touchscreen` platform. It is also used by the LVGL component.\n\n*See also: [Touchscreen Components](https://esphome.io/components/touchscreen/index.html#touchscreen-components)*"
      },
      "update": {},
      "valve": {
        "docs": "The `valve` component is a generic representation of valves in ESPHome. A valve can (currently) either be *closed* or *open* and supports three commands: *open*, *close* and *stop*.\n\n*See also: [Valve Component](https://esphome.io/components/valve/index.html#valve-component)*"
      }
    },
    "components": {
      "esphome": {
        "docs": "Here you specify some core information that ESPHome needs to create firmwares. Most importantly, this is the section of the configuration where you specify the **name** of the node.\n\n*See also: [ESPHome Core Configuration](https://esphome.io/components/esphome.html#esphome-core-configuration)*"
      },
      "esp32": {
        "docs": "This is an alternative base framework for ESP32 chips; it is recommended for variants of the ESP32 like ESP32S2, ESP32S3, ESP32C3 and single-core ESP32 chips.\n\n*See also: [ESP-IDF framework](https://esphome.io/components/esp32.html#esp-idf-framework)*"
      },
      "esp8266": {
        "docs": "This component contains platform-specific options for the ESP8266 platform.\n\n*See also: [ESP8266 Platform](https://esphome.io/components/esp8266.html#esp8266-platform)*"
      },
      "adalight": {
        "dependencies": [
          "uart"
        ]
      },
      "adc128s102": {
        "dependencies": [
          "spi"
        ],
        "docs": "The ADC128S102 component allows you to use ADC128S102 8-Channel 12-Bit A/D Converter ([datasheet](https://www.ti.com/lit/ds/symlink/adc128s102.pdf), [Texas Instruments](https://www.ti.com/product/ADC128S102)) in ESPHome. It uses the [SPI Bus](https://esphome.io/components/spi.html#spi) for communication.\n\n*See also: [adc128s102 Component/Hub](https://esphome.io/components/sensor/adc128s102.html#component-hub)*"
      },
      "ads1115": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The `ads1115` domain creates a global hub so that you can later create individual sensors using the [ADS1115 Sensor Platform](https://esphome.io/components/sensor/ads1115.html#ads1115-sensor). To use this hub, first setup the [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) and connect the sensor to the pins specified there.\n\n*See also: [ads1115 Component/Hub](https://esphome.io/components/sensor/ads1115.html#component-hub)*"
      },
      "ads1118": {
        "dependencies": [
          "spi"
        ],
        "docs": "ADS1118 4-Channel 16-Bit A/D Converter ([datasheet](https://www.ti.com/lit/ds/symlink/ads1118.pdf)) The `ads1118` domain creates a global hub so that you can later create individual sensors using the [ADS1118 Sensor Platform](https://esphome.io/components/sensor/ads1118.html#ads1118-sensor). It uses the [SPI Bus](https://esphome.io/components/spi.html#spi) for communication.\n\n*See also: [ads1118 Component/Hub](https://esphome.io/components/sensor/ads1118.html#component-hub)*"
      },
      "airthings_ble": {
        "dependencies": [
          "esp32_ble_tracker"
        ]
      },
      "animation": {
        "dependencies": [
          "display"
        ],
        "docs": "Allows to use animated images on displays. Animation inherits all options from the image component. It adds additional lambda methods: `next_frame()`, `prev_frame()` and `set_frame()` to change the shown picture of a gif.\n\n*See also: [Animation](https://esphome.io/components/animation.html#animation)*"
      },
      "apds9960": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The `apds9960` sensor platform allows you to use your APDS9960 RGB and gesture sensors ([datasheet](https://cdn.sparkfun.com/datasheets/Sensors/Proximity/apds9960.pdf), [SparkFun](https://www.sparkfun.com/products/12787)) with ESPHome. The [I\u00b2C](https://esphome.io/components/i2c.html#i2c) is required to be set up in your configuration for this sensor to work.\n\n*See also: [apds9960 Component/Hub](https://esphome.io/components/sensor/apds9960.html#component-hub)*"
      },
      "api": {
        "dependencies": [
          "network"
        ],
        "docs": "The ESPHome native API is used to communicate with clients directly, with a highly-optimized network protocol. Currently, only the ESPHome tool, Home Assistant and ioBroker use this native API.\n\n*See also: [Native API Component](https://esphome.io/components/api.html#native-api-component)*"
      },
      "as3935_i2c": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The `as3935_i2c` sensor platform allows you to use your AS3935 sensor ([AMS_AS3935](https://ams.com/as3935)) in order to get notified when a thunderstorm is getting close.\n\n*See also: [as3935 Over I\u00b2C](https://esphome.io/components/sensor/as3935.html#over-i2c)*"
      },
      "as3935_spi": {
        "dependencies": [
          "spi"
        ],
        "docs": "The `as3935_spi` sensor platform allows you to use your AS3935 sensor ([AMS_AS3935](https://ams.com/as3935)) in order to get notified when a thunderstorm is getting close.\n\n*See also: [as3935 Over SPI](https://esphome.io/components/sensor/as3935.html#over-spi)*"
      },
      "as5600": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The `as5600` sensor platform you to use your AS5600 ([datasheet](https://ams.com/documents/20143/36005/AS5600_DS000365_5-00.pdf/649ee61c-8f9a-20df-9e10-43173a3eb323), [AMS](https://ams.com/en/as5600)) or AS5600L ([datasheet](https://ams.com/documents/20143/36005/AS5600L_DS000545_3-00.pdf/7ade6878-7a32-2294-b88d-479d50fab6de), [AMS](https://ams.com/en/as5600l)) 12-bit magnetic position sensor with ESPHome. Individual sensors will be added using the [AS5600 Sensor Platform](https://esphome.io/components/sensor/as5600.html#as5600-sensor). To use this hub, first setup the [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) and connect the sensor to the pins specified there.\n\n*See also: [as5600 Component/Hub](https://esphome.io/components/sensor/as5600.html#component-hub)*"
      },
      "async_tcp": {},
      "at581x": {
        "dependencies": [
          "i2c"
        ],
        "docs": "You need to have the hub component (`at581x:` entry) defined to be able to change the sensor\u2019s settings, get it listed as an motion entity or being able to turn on/off the radio frequency emmission. A [GPIO Binary Sensor](https://esphome.io/components/binary_sensor/gpio.html) alone could be sufficient if you only want to determine presence/occupancy. When you define `at581x:` you\u2019ll need to have a `i2c:` entry in your configuration with both the SDA and SCL pins defined.\n\n*See also: [at581x Component/Hub](https://esphome.io/components/at581x.html#component-hub)*"
      },
      "audio": {},
      "bedjet": {
        "dependencies": [
          "ble_client"
        ],
        "docs": "This component is a global hub that maintains the connection to the BedJet device and delegates status updates to individual platform components.\n\n*See also: [bedjet Component/Hub](https://esphome.io/components/climate/bedjet.html#component-hub)*"
      },
      "bk72xx": {
        "docs": "This component contains platform-specific options for the [LibreTiny](https://docs.libretiny.eu/) platform. It provides support for the following microcontrollers, commonly used in Tuya devices, amongst others:\n\n*See also: [LibreTiny Platform](https://esphome.io/components/libretiny.html#libretiny-platform)*"
      },
      "ble_client": {
        "dependencies": [
          "esp32_ble_tracker"
        ],
        "docs": "The `ble_client` component enables connections to Bluetooth Low Energy devices in order to query and control them. This component does not expose any sensors or output components itself, but merely manages connections to them for use by other components.\n\n*See also: [BLE Client](https://esphome.io/components/ble_client.html#ble-client)*"
      },
      "bluetooth_proxy": {
        "dependencies": [
          "api",
          "esp32"
        ],
        "docs": "Home Assistant can expand its Bluetooth reach by communicating through the Bluetooth proxy component in ESPHome. The individual device integrations in Home Assistant (such as BTHome) will receive the data from the Bluetooth Integration in Home Assistant which automatically aggregates all ESPHome Bluetooth proxies with any USB Bluetooth Adapters you might have. This exceptional feature offers fault tolerant connection between the Bluetooth devices and Home Assistant.\n\n*See also: [Bluetooth Proxy](https://esphome.io/components/bluetooth_proxy.html#bluetooth-proxy)*"
      },
      "bme680_bsec": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The `bme680_bsec` sensor platform allows you to use your BME680 ([datasheet](https://www.bosch-sensortec.com/media/boschsensortec/downloads/datasheets/bst-bme680-ds001.pdf), [Adafruit](https://www.adafruit.com/product/3660), [Pimoroni](https://shop.pimoroni.com/products/bme680-breakout)) temperature, pressure and humidity and gas sensors with ESPHome via the Bosch Sensortec Environmental Cluster (BSEC) software library. The use of Bosch\u2019s proprietary algorithms provide an Index for Air Quality (IAQ) measurement derived from the gas resistance sensor\u2019s response to specific Volatile Organic Compounds (VOC). The BSEC software also provides estimated values for CO\u2082 and Breath Volatile Organic Compounds (b-VOC) using a correlation between VOC and CO\u2082 in a human\u2019s exhaled breath.\n\n*See also: [bme680_bsec Component/Hub](https://esphome.io/components/sensor/bme680_bsec.html#component-hub)*"
      },
      "bme68x_bsec2_i2c": {
        "dependencies": [
          "i2c"
        ]
      },
      "bp1658cj": {
        "docs": "The BP1658CJ component represents a BP1658CJ LED driver chain in ESPHome. Communication is done with two GPIO pins (DATA and CLK).\n\n*See also: [bp1658cj Component/Hub](https://esphome.io/components/output/bp1658cj.html#component-hub)*"
      },
      "bp5758d": {
        "docs": "The BP5758D component represents a BP5758D LED driver chain in ESPHome. Communication is done with two GPIO pins (DATA and CLK).\n\n*See also: [bp5758d Component/Hub](https://esphome.io/components/output/bp5758d.html#component-hub)*"
      },
      "bytebuffer": {},
      "cap1188": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The `cap1188` sensor platform allows you to use your CAP1188 ([datasheet](https://cdn-shop.adafruit.com/datasheets/CAP1188.pdf), [Adafruit](https://learn.adafruit.com/adafruit-cap1188-breakout/overview)) Capacitive Touch Sensor with ESPHome. The [I\u00b2C](https://esphome.io/components/i2c.html#i2c) bus is required to be set up in your configuration for this sensor to work.\n\n*See also: [cap1188 Component/Hub](https://esphome.io/components/binary_sensor/cap1188.html#component-hub)*"
      },
      "captive_portal": {
        "dependencies": [
          "wifi"
        ],
        "docs": "The captive portal component in ESPHome is a fallback mechanism for when connecting to the configured [WiFi](https://esphome.io/components/wifi.html) fails.\n\n*See also: [Captive Portal](https://esphome.io/components/captive_portal.html#captive-portal)*"
      },
      "cd74hc4067": {
        "docs": "**[Pin](https://esphome.io/guides/configuration-types.html#config-pin)**: The I/O pins connected to the S0 to S3 channel selection pins\n\n*See also: [cd74hc4067 Component/Hub](https://esphome.io/components/sensor/cd74hc4067.html#component-hub)*"
      },
      "ch422g": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The CH422G component allows you to use the **CH422G** I/O expander in ESPHome. It uses an [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) for communication. The I\u00b2C address is not configurable as the CH422G has a separate address for each internal register.\n\n*See also: [CH422G I/O Expander](https://esphome.io/components/ch422g.html#ch422g-i-o-expander)*"
      },
      "color": {},
      "custom_component": {},
      "dac7678": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The DAC7678 component represents a DAC7678 12-bit 8 channel DAC with internal reference ([datasheet](https://www.ti.com/lit/ds/symlink/dac7678.pdf)) in ESPHome. It uses the [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) for communication.\n\n*See also: [dac7678 Component/Hub](https://esphome.io/components/output/dac7678.html#component-hub)*"
      },
      "dallas": {},
      "daly_bms": {
        "dependencies": [
          "uart"
        ],
        "docs": "**[Time](https://esphome.io/guides/configuration-types.html#config-time)**: Delay between data requests.\n\n*See also: [daly_bms Component/Hub](https://esphome.io/components/sensor/daly_bms.html#component-hub)*"
      },
      "dashboard_import": {
        "dependencies": [
          "api"
        ]
      },
      "debug": {
        "dependencies": [
          "logger"
        ],
        "docs": "The `debug` component can be used to debug problems with ESPHome. At startup, it prints a bunch of useful information like reset reason, free heap size, ESPHome version and so on. It also allows you to get the same information as a text sensor, and to monitor the state of the ESP heap memory (free space, maximum free block size and fragmentation level) and the main-loop timing.\n\n*See also: [Debug Component](https://esphome.io/components/debug.html#debug-component)*"
      },
      "deep_sleep": {
        "docs": "The `deep_sleep` component can be used to automatically enter a deep sleep mode on the ESP8266/ESP32 after a certain amount of time. This is especially useful with nodes that operate on batteries and therefore need to conserve as much energy as possible.\n\n*See also: [Deep Sleep Component](https://esphome.io/components/deep_sleep.html#deep-sleep-component)*"
      },
      "demo": {
        "docs": "The `demo` component can be used for testing to generate sample instances of many different components (sensors, lights, \u2026)\n\n*See also: [Demo Component](https://esphome.io/components/demo.html#demo-component)*"
      },
      "dfplayer": {
        "dependencies": [
          "uart"
        ],
        "docs": "The `dfplayer` ([datasheet](https://wiki.dfrobot.com/DFPlayer_Mini_SKU_DFR0299)), component allows you to play sound and music stored in an SD card or USB flash drive.\n\n*See also: [DF-Player mini](https://esphome.io/components/dfplayer.html#df-player-mini)*"
      },
      "dfrobot_sen0395": {
        "dependencies": [
          "uart"
        ],
        "docs": "The [DFRobot mmWave Radar](https://wiki.dfrobot.com/mmWave_Radar_Human_Presence_Detection_SKU_SEN0395) (aka `SEN0395`) is a 24GHz radar which can be used for human presence detection. It can detect tiny movements and compared to a PIR sensor **it can detect presence continuously**. This can be useful, for example, to turn the lights on when you enter a room, keep them on as long as you are there (without waving your hands at the sensor) and turn them off almost immediately after you leave the room.\n\n*See also: [DFRobot mmWave Radar](https://esphome.io/components/dfrobot_sen0395.html#dfrobot-mmwave-radar)*"
      },
      "dsmr": {
        "dependencies": [
          "uart"
        ],
        "docs": "The DSMR component connects to Dutch Smart Meters which comply to DSMR (Dutch Smart Meter Requirements), also known as \u2018Slimme meter\u2019 or \u2018P1 port\u2019.\n\n*See also: [dsmr Component/Hub](https://esphome.io/components/sensor/dsmr.html#component-hub)*"
      },
      "e131": {
        "dependencies": [
          "network"
        ]
      },
      "emc2101": {
        "dependencies": [
          "i2c"
        ],
        "docs": "**int**: Manually specify the I\u00b2C address of the sensor. Defaults to `0x4C`.\n\n*See also: [EMC2101 Component](https://esphome.io/components/emc2101.html#emc2101-component)*"
      },
      "esp32_ble": {
        "dependencies": [
          "esp32"
        ],
        "docs": "The `esp32_ble` component in ESPHome sets up the Bluetooth LE stack on the device so that a [BLE Server](https://esphome.io/components/esp32_ble_server.html) can run.\n\n*See also: [BLE Component](https://esphome.io/components/esp32_ble.html#ble-component)*"
      },
      "esp32_ble_beacon": {
        "dependencies": [
          "esp32"
        ],
        "docs": "The `esp32_ble_beacon` component creates a Bluetooth Low Energy Beacon with your ESP32 device. Beacons are BLE devices that repeatedly just send out a pre-defined packet of data. This packet can then be received by devices like smartphones and can then be used to track a phone\u2019s location.\n\n*See also: [ESP32 Bluetooth Low Energy Beacon](https://esphome.io/components/esp32_ble_beacon.html#esp32-bluetooth-low-energy-beacon)*"
      },
      "esp32_ble_server": {
        "dependencies": [
          "esp32"
        ],
        "docs": "The `esp32_ble_server` component in ESPHome sets up a  BLE GATT server that exposes the device name, manufacturer and board. BLE GATT services and characteristics can be added to the server to expose data and control.\n\n*See also: [BLE Server](https://esphome.io/components/esp32_ble_server.html#ble-server)*"
      },
      "esp32_ble_tracker": {
        "dependencies": [
          "esp32"
        ],
        "docs": "The `esp32_ble_tracker` component creates a global hub so that you can track bluetooth low energy devices using your ESP32 node.\n\n*See also: [ESP32 Bluetooth Low Energy Tracker Hub](https://esphome.io/components/esp32_ble_tracker.html#esp32-bluetooth-low-energy-tracker-hub)*"
      },
      "esp32_camera": {
        "dependencies": [
          "esp32"
        ],
        "docs": "The `esp32_camera` component allows you to use ESP32-based camera boards in ESPHome that directly integrate into Home Assistant through the native API.\n\n*See also: [ESP32 Camera Component](https://esphome.io/components/esp32_camera.html#esp32-camera-component)*"
      },
      "esp32_camera_web_server": {
        "dependencies": [
          "esp32_camera"
        ],
        "docs": "The `esp32_camera_web_server` component allows you to use expose web server of ESP32-based camera boards in ESPHome that directly can be integrated into external surveillance or PVR software.\n\n*See also: [ESP32 Camera Web Server Component](https://esphome.io/components/esp32_camera_web_server.html#esp32-camera-web-server-component)*"
      },
      "esp32_improv": {
        "dependencies": [
          "wifi",
          "esp32"
        ],
        "docs": "The `esp32_improv` component in ESPHome implements the open [Improv standard](https://www.improv-wifi.com/) for configuring Wi-Fi on an ESP32 device by using Bluetooth Low Energy (BLE) to receive the credentials.\n\n*See also: [Improv via BLE](https://esphome.io/components/esp32_improv.html#improv-via-ble)*"
      },
      "esp32_touch": {
        "dependencies": [
          "esp32"
        ],
        "docs": "The `esp32_touch` component creates a global hub enabling (capacitive) touch detection on GPIO pins [supported by ESP32, ESP32-S2 or ESP32-S3 processors](https://esphome.io/components/binary_sensor/esp32_touch.html#esp32-touch-pad-pins). With this enabled, [binary sensors](https://esphome.io/components/binary_sensor/esp32_touch.html#esp32-touch-binary-sensor) may then be configured to permit touch detection.\n\n*See also: [esp32_touch Component/Hub](https://esphome.io/components/binary_sensor/esp32_touch.html#component-hub)*"
      },
      "ethernet": {
        "dependencies": [
          "esp32"
        ],
        "docs": "This ESPHome component enables *wired* Ethernet connections for ESP32s.\n\n*See also: [Ethernet Component](https://esphome.io/components/ethernet.html#ethernet-component)*"
      },
      "event_emitter": {},
      "exposure_notifications": {
        "dependencies": [
          "esp32_ble_tracker"
        ],
        "docs": "The `exposure_notifications` component uses the [ESP32 Bluetooth Low Energy Tracker Hub](https://esphome.io/components/esp32_ble_tracker.html) to discover nearby COVID-19 exposure notification bluetooth messages sent by phones running the [Google/Apple Exposure Notification service](https://www.google.com/covid19/exposurenotifications/).\n\n*See also: [Exposure Notification Listener](https://esphome.io/components/exposure_notifications.html#exposure-notification-listener)*"
      },
      "external_components": {
        "docs": "You can easily import community or personal components using the external components feature. Bundled components can be overridden using this feature.\n\n*See also: [External Components](https://esphome.io/components/external_components.html#external-components)*"
      },
      "ezo_pmp": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The `ezo_pmp` component allows you to use an Atlas Scientific Peristaltic Pump with ESPHome. Both the EZO-PMP ([datasheet](https://files.atlas-scientific.com/EZO_PMP_Datasheet.pdf)) and EZO-PMP-L ([datasheet](https://files.atlas-scientific.com/EZO_PMP_L_Datasheet.pdf)) are supported. The [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) is required to be set up in your configuration for this sensor to work.\n\n*See also: [Atlas Scientific Peristaltic Pump](https://esphome.io/components/ezo_pmp.html#atlas-scientific-peristaltic-pump)*"
      },
      "fingerprint_grow": {
        "dependencies": [
          "uart"
        ],
        "docs": "The reader can be powered by the 3.3V output of an NodeMCU. As the communication with the reader is done using UART (default baud rate is 57600), you need to have an [UART bus](https://esphome.io/components/uart.html#uart) in your configuration with the `rx_pin` connected to the reader\u2019s `TX` and the `tx_pin` connected to the reader\u2019s `RX`.\n\n*See also: [fingerprint_grow Component/Hub](https://esphome.io/components/fingerprint_grow.html#component-hub)*"
      },
      "font": {
        "docs": "ESPHome\u2019s graphical rendering engine also has a powerful font drawer which integrates seamlessly into the system. You have the option to use **any** OpenType/TrueType (`.ttf`, `.otf`, `.woff`) font file at **any** size, as well as fixed-size [PCF](https://en.wikipedia.org/wiki/Portable_Compiled_Format) and [BDF](https://en.wikipedia.org/wiki/Glyph_Bitmap_Distribution_Format) bitmap fonts.\n\n*See also: [Font Renderer Component](https://esphome.io/components/font.html#font-renderer-component)*"
      },
      "gdk101": {
        "dependencies": [
          "i2c"
        ],
        "docs": "**int**: Manually specify the I\u00b2C address of the sensor. Defaults to `0x18` (`A0` and `A1` shorted). The address is made up using the state of `A0` as bit 1 and the state of `A1` as bit 2, so a total of four addresses is possible.\n\n*See also: [gdk101 Component/Hub](https://esphome.io/components/sensor/gdk101.html#component-hub)*"
      },
      "globals": {
        "docs": "In some cases you might need to share a global variable across multiple lambdas. For example, global variables can be used to store the state of a garage door.\n\n*See also: [Global Variables](https://esphome.io/components/globals.html#global-variables)*"
      },
      "gp8403": {
        "dependencies": [
          "i2c"
        ],
        "docs": "Configuration variables:\n\n*See also: [gp8403 Component/Hub](https://esphome.io/components/output/gp8403.html#component-hub)*"
      },
      "gps": {
        "dependencies": [
          "uart"
        ],
        "docs": "The `gps` component allows you to connect GPS modules to your ESPHome project. Any GPS module that uses the standardized NMEA communication protocol will work.\n\n*See also: [GPS Component](https://esphome.io/components/gps.html#gps-component)*"
      },
      "graph": {
        "dependencies": [
          "display",
          "sensor"
        ],
        "docs": "You can display a graph of a sensor value(s) using this component. The states used for the graph are stored in memory at the time the sensor updates and will be lost when the device reboots.\n\n*See also: [Graph Component](https://esphome.io/components/graph.html#graph-component)*"
      },
      "graphical_display_menu": {
        "docs": "The component provides an infrastructure for setting up a hierarchical menu on graphical displays. This offers the user an interactive method to display labels, control entities like `switch`, `select`, `number`  available locally on the ESPHome node, without the requirement of a network connection.\n\n*See also: [Graphical Display Menu](https://esphome.io/components/display_menu/graphical_display_menu.html#graphical-display-menu)*"
      },
      "grove_tb6612fng": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The Grove TBB6612FNG a runs over  I\u00b2C bus and has the capability to control DC and Stepper motors. At the current stage of implementation only DC motor is implemented.\n\n*See also: [Grove TB6612FNG Motor Drive](https://esphome.io/components/grove_tb6612fng.html#grove-tb6612fng-motor-drive)*"
      },
      "host": {
        "docs": "The `host` platform allows ESPHome configurations to be compiled and run on a desktop computer. This is known to work on MacOS and Linux. On Windows [WSL](https://learn.microsoft.com/en-us/windows/wsl/install) (Windows Subsystem for Linux) can be used to create a Linux environment that will run ESPHome.\n\n*See also: [Host Platform](https://esphome.io/components/host.html#host-platform)*"
      },
      "http_request": {
        "dependencies": [
          "network"
        ],
        "docs": "The `http_request` component lets you make HTTP/HTTPS requests. To do so, you need to add it to your device\u2019s configuration:\n\n*See also: [HTTP Request](https://esphome.io/components/http_request.html#http-request)*"
      },
      "i2c": {
        "docs": "This component sets up the I\u00b2C bus for your ESP32 or ESP8266. In order for these components to work correctly, you need to define the I\u00b2C bus in your configuration. Please note the ESP will enable its internal 10k\u2126 pullup resistors for these pins, so you usually don\u2019t need to put on external ones. You can use multiple devices on one I\u00b2C bus as each device is given a unique address for communicating between it and the ESP. You can do this by hopping wires from the two lines (SDA and SCL) from each device board to the next device board or by connecting the wires from each device back to the two I\u00b2C pins on the ESP.\n\n*See also: [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c-bus)*"
      },
      "i2c_device": {
        "dependencies": [
          "i2c"
        ],
        "docs": "General-purpose I\u00b2C device component that can be used to communicate with hardware not supported by a specific component. It allows selection of the I\u00b2C address. Reads and writes on the device can be performed with lambdas. For example:\n\n*See also: [Generic I\u00b2C device component:](https://esphome.io/components/i2c_device.html#generic-i2c-device-component)*"
      },
      "i2s_audio": {
        "dependencies": [
          "esp32"
        ],
        "docs": "The `i2s_audio` component allows for sending and receiving audio via I\u00b2S. This component only works on ESP32 based chips.\n\n*See also: [I\u00b2S Audio Component](https://esphome.io/components/i2s_audio.html#i2s-audio-component)*"
      },
      "image": {
        "dependencies": [
          "display"
        ],
        "docs": "Use this component to store graphical images on the device, you can then draw the images on compatible displays.\n\n*See also: [Images](https://esphome.io/components/image.html#images)*"
      },
      "improv_serial": {
        "dependencies": [
          "logger",
          "wifi"
        ],
        "docs": "The `improv_serial` component in ESPHome implements the open [Improv standard](https://www.improv-wifi.com/) for configuring Wi-Fi on an ESPHome device by using a serial connection to the device, eg. USB.\n\n*See also: [Improv via Serial](https://esphome.io/components/improv_serial.html#improv-via-serial)*"
      },
      "interval": {
        "docs": "This component allows you to run actions at fixed time intervals. For example, if you want to toggle a switch every minute, you can use this component. Please note that it\u2019s possible to achieve the same thing with the [time.on_time](https://esphome.io/components/time/index.html#time-on-time) trigger, but this technique is more light-weight and user-friendly.\n\n*See also: [Interval Component](https://esphome.io/components/interval.html#interval-component)*"
      },
      "json": {
        "docs": "The `json` component enables ESPHome to work with JSON data in automations, sensors, and HTTP requests. This is particularly useful for:\n\n*See also: [json Component](https://esphome.io/components/json.html#json-component)*"
      },
      "key_collector": {
        "docs": "The `key_collector` component collects key presses from components like [Matrix keypad](https://esphome.io/components/matrix_keypad.html#matrix-keypad), [Wiegand keypad](https://esphome.io/components/wiegand.html) or LVGL [Button Matrix](https://esphome.io/components/lvgl/widgets.html#lvgl-widget-buttonmatrix), [Keyboard](https://esphome.io/components/lvgl/widgets.html#lvgl-widget-keyboard) widgets. It allows you to process key sequences and treat them as one, for example to allow inputting of a PIN code or a passkey. The component outputs the result of the keypress sequence as a variable usable in automations.\n\n*See also: [Key collector component](https://esphome.io/components/key_collector.html#key-collector-component)*"
      },
      "lcd_menu": {
        "docs": "The component provides an infrastructure for setting up a hierarchical menu on character based LCD displays. This offers the user an interactive method to display labels, control entities like `switch`, `select`, `number`  available locally on the ESPHome node, without the requirement of a network connection.\n\n*See also: [LCD Menu](https://esphome.io/components/display_menu/lcd_menu.html#lcd-menu)*"
      },
      "ld2410": {
        "dependencies": [
          "uart"
        ],
        "docs": "The `ld2410` sensor platform allows you to use HI-LINK LD2410 motion and presence sensors with ESPHome. There are three variants with similar communication protocols:\n\n*See also: [ld2410 Component/Hub](https://esphome.io/components/sensor/ld2410.html#component-hub)*"
      },
      "ld2420": {
        "dependencies": [
          "uart"
        ]
      },
      "ld2450": {
        "dependencies": [
          "uart"
        ]
      },
      "libretiny": {},
      "lightwaverf": {
        "docs": "The `LightWaveRF` light platform creates a module to dump and send commands to light switches\n\n*See also: [LightWaveRF](https://esphome.io/components/lightwaverf.html#lightwaverf)*"
      },
      "logger": {
        "docs": "The logger component automatically logs all log messages through the serial port and through MQTT topics (if there is an MQTT client in the configuration). By default, all logs with a severity `DEBUG` or higher will be shown. Increasing the log level severity (to e.g `INFO` or `WARN`) can help with the performance of the application and memory size.\n\n*See also: [Logger Component](https://esphome.io/components/logger.html#logger-component)*"
      },
      "lvgl": {
        "dependencies": [
          "display"
        ]
      },
      "m5stack_8angle": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The `m5stack_8angle` platform allows to use the [m5angle]([https://docs.m5stack.com/en/unit/UNIT%208Angle](https://docs.m5stack.com/en/unit/UNIT%208Angle)) input device with ESPHome. It has 8 knobs, a switch and can individually drive 9 RGB LEDs.\n\n*See also: [m5stack_8angle Component/Hub](https://esphome.io/components/sensor/m5stack_8angle.html#component-hub)*"
      },
      "mapping": {},
      "matrix_keypad": {
        "docs": "The `matrix_keypad` component allows you to integrate pads which have the keys connected at the intersection points of the rows and columns of a matrix.\n\n*See also: [Matrix keypad](https://esphome.io/components/matrix_keypad.html#matrix-keypad)*"
      },
      "max6956": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The `max6956` is an [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) slave. Its address is configured using A0 and A1 hardware pins from 0x40 to 0x4F.\n\n*See also: [max6956 Component/Hub](https://esphome.io/components/max6956.html#component-hub)*"
      },
      "mcp23008": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The MCP23008 component ([datasheet](http://ww1.microchip.com/downloads/en/devicedoc/21919e.pdf), [Adafruit](https://www.adafruit.com/product/593)) has 8 GPIOs that can be configured independently.\n\n*See also: [MCP23008 Component](https://esphome.io/components/mcp230xx.html#mcp23008-component)*"
      },
      "mcp23016": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The MCP23016 component ([datasheet](http://ww1.microchip.com/downloads/en/devicedoc/20090c.pdf)) has 16 GPIOs and can be configured the same way than the other variants.\n\n*See also: [MCP23016 Component](https://esphome.io/components/mcp230xx.html#mcp23016-component)*"
      },
      "mcp23017": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The MCP23017 component allows you to use MCP23017 I/O expanders ([datasheet](http://ww1.microchip.com/downloads/en/devicedoc/20001952c.pdf), [Adafruit](https://www.adafruit.com/product/732)) in ESPHome. It uses the [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) for communication.\n\n*See also: [MCP23017 Component](https://esphome.io/components/mcp230xx.html#mcp23017-component)*"
      },
      "mcp23s08": {
        "dependencies": [
          "spi"
        ],
        "docs": "The MCP23S08 component ([datasheet](http://ww1.microchip.com/downloads/en/DeviceDoc/MCP23008-MCP23S08-Data-Sheet-20001919F.pdf), [Digi-Key](https://www.digikey.com/product-detail/en/microchip-technology/MCP23S08-E-P/MCP23S08-E-P-ND/735954)) has 8 GPIOs that can be configured independently.\n\n*See also: [MCP23S08 Component](https://esphome.io/components/mcp23Sxx.html#mcp23s08-component)*"
      },
      "mcp23s17": {
        "dependencies": [
          "spi"
        ],
        "docs": "The MCP23S17 component allows you to use MCP23S17 I/O expanders ([datasheet](http://ww1.microchip.com/downloads/en/DeviceDoc/20001952C.pdf), [Digi-Key](https://www.digikey.com/product-detail/en/microchip-technology/MCP23S17-E-SP/MCP23S17-E-SP-ND/894276)) in ESPHome. It uses the [SPI Bus](https://esphome.io/components/spi.html#spi) for communication.\n\n*See also: [MCP23S17 Component](https://esphome.io/components/mcp23Sxx.html#mcp23s17-component)*"
      },
      "mcp3008": {
        "dependencies": [
          "spi"
        ],
        "docs": "The MCP3008 component allows you to use MCP3008 8-Channel 10-Bit A/D Converter ([datasheet](http://ww1.microchip.com/downloads/en/DeviceDoc/21295d.pdf), [Adafruit](https://www.adafruit.com/product/856)) in ESPHome. It uses the [SPI Bus](https://esphome.io/components/spi.html#spi) for communication.\n\n*See also: [mcp3008 Component/Hub](https://esphome.io/components/sensor/mcp3008.html#component-hub)*"
      },
      "mcp3204": {
        "dependencies": [
          "spi"
        ],
        "docs": "The MCP3204 component allows you to use MCP3204 or MCP3208 12-Bit A/D Converter ([datasheet](https://ww1.microchip.com/downloads/en/DeviceDoc/21298e.pdf)) in ESPHome. The MCP3204 is a 4-channel and MCP3208 is an 8-channel device. It uses the [SPI Bus](https://esphome.io/components/spi.html#spi) for communication.\n\n*See also: [mcp3204 Component/Hub](https://esphome.io/components/sensor/mcp3204.html#component-hub)*"
      },
      "mcp4461": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The MCP4461 output component enables the use of an 8\u2011bit external quad digital potentiometer/rheostat via I\u00b2C. See the [MCP4461 Datasheet](https://www.microchip.com/en-us/product/mcp4461) for more information.\n\n*See also: [MCP4461 Component](https://esphome.io/components/output/mcp4461.html#mcp4461-component)*"
      },
      "mcp4728": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The MCP4728 output component allows to use [12bit external quad DAC](https://www.adafruit.com/product/4470) in order to have analog outputs on any board by using [I\u00b2C](https://esphome.io/components/i2c.html#i2c). Devices default address is `0x60`.\n\n*See also: [MCP4728 Component](https://esphome.io/components/output/mcp4728.html#mcp4728-component)*"
      },
      "mdns": {
        "dependencies": [
          "network"
        ],
        "docs": "The `mdns` component makes the node announce itself on the local network using the multicast DNS (mDNS) protocol.\n\n*See also: [mDNS Component](https://esphome.io/components/mdns.html#mdns-component)*"
      },
      "micronova": {
        "dependencies": [
          "uart"
        ],
        "docs": "**[Pin](https://esphome.io/guides/configuration-types.html#config-pin)**: Output pin to be used to switch the line between RX and TX.\n\n*See also: [micronova Component/Hub](https://esphome.io/components/micronova.html#component-hub)*"
      },
      "micro_wake_word": {
        "dependencies": [
          "microphone"
        ],
        "docs": "ESPHome implements an on-device wake word detection framework from [microWakeWord](https://github.com/kahrendt/microWakeWord). This repository/library allows you to create a custom wake word for your ESPHome device.\n\n*See also: [Micro Wake Word](https://esphome.io/components/micro_wake_word.html#micro-wake-word)*"
      },
      "modbus": {
        "dependencies": [
          "uart"
        ],
        "docs": "The Modbus protocol is used by many consumer and industrial devices for communication. This component allows components in ESPHome to communicate to those devices via RTU protocol. You can access the coils, inputs, holding, read registers from your devices as sensors, switches, selects, numbers or various other ESPHome components and present them to your favorite Home Automation system. You can even write them as binary or float ouptputs from ESPHome.\n\n*See also: [Modbus Component](https://esphome.io/components/modbus.html#modbus-component)*"
      },
      "modbus_controller": {
        "docs": "The `modbus_controller` component creates a RS485 connection to either:\n\n*See also: [Modbus Controller](https://esphome.io/components/modbus_controller.html#modbus-controller)*"
      },
      "mopeka_ble": {
        "dependencies": [
          "esp32_ble_tracker"
        ]
      },
      "mpr121": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The `mpr121` sensor platform allows you to use your MPR121 ([datasheet](https://cdn-learn.adafruit.com/downloads/pdf/adafruit-mpr121-12-key-capacitive-touch-sensor-breakout-tutorial.pdf), [Adafruit](https://learn.adafruit.com/adafruit-mpr121-12-key-capacitive-touch-sensor-breakout-tutorial/overview)) Capacitive Touch Sensor with ESPHome. The [I\u00b2C](https://esphome.io/components/i2c.html#i2c) is required to be set up in your configuration for this sensor to work.\n\n*See also: [mpr121 Component/Hub](https://esphome.io/components/binary_sensor/mpr121.html#component-hub)*"
      },
      "mqtt": {
        "dependencies": [
          "network"
        ],
        "docs": "With the MQTT Message schema you can tell ESPHome how a specific MQTT message should be sent. It is used in several places like last will and birth messages or MQTT log options.\n\n*See also: [MQTTMessage](https://esphome.io/components/mqtt.html#mqttmessage)*"
      },
      "msa3xx": {
        "dependencies": [
          "i2c"
        ]
      },
      "my9231": {
        "docs": "The MY9231/MY9291 component represents a MY9231/MY9291 LED driver chain ([MY9231 description](http://www.my-semi.com.tw/file/MY9231_BF_0.91.pdf), [MY9291 description](http://www.my-semi.com.tw/file/MY9291_BF_0.91.pdf)) in ESPHome. Communication is done with two GPIO pins (DI and DCKI) and multiple driver chips can be chained. There are two models with different number of output channels (MY9291 with 4 channels and MY9231 with 3 channels). They are popular driver chips used in smart light bulbs:\n\n*See also: [my9231 Component/Hub](https://esphome.io/components/output/my9231.html#component-hub)*"
      },
      "network": {
        "docs": "The network component is a global configuration for all types of networks (WiFi, Ethernet).\n\n*See also: [Network component](https://esphome.io/components/network.html#network-component)*"
      },
      "online_image": {
        "dependencies": [
          "display",
          "http_request"
        ],
        "docs": "With this component you can define images that will be downloaded, decoded and drawn at runtime.\n\n*See also: [Online Image Component](https://esphome.io/components/online_image.html#online-image-component)*"
      },
      "opentherm": {
        "docs": "OpenTherm (OT) is a standard communications protocol used in central heating systems for the communication between central heating appliances and a thermostatic controller. As a standard, OpenTherm is independent of any single manufacturer. A controller from manufacturer A can in principle be used to control a boiler from manufacturer B.\n\n*See also: [OpenTherm](https://esphome.io/components/opentherm.html#opentherm)*"
      },
      "packages": {
        "docs": "When you have many ESPHome devices (or are producing and distributing them at scale), a common need tends to surface: configuration modularization. You\u2019ll likely want to break your configuration into common (groups of) elements, building it into reusable pieces which can subsequently be used by many/all devices. Only unique pieces of your configuration remain in any given device\u2019s YAML configuration file.\n\n*See also: [Packages](https://esphome.io/components/packages.html#packages)*"
      },
      "pca6416a": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The PCA6416A component allows you to use **PCA6416A** or **PCAL6416A** I/O expanders in ESPHome. It uses [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) for communication.\n\n*See also: [PCA6416A I/O Expander](https://esphome.io/components/pca6416a.html#pca6416a-i-o-expander)*"
      },
      "pca9554": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The PCA9554 component allows you to use a variety of Texas Instrument I/O expanders in ESPHome using the [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) for communication.\n\n*See also: [PCA9554 I/O Expander](https://esphome.io/components/pca9554.html#pca9554-i-o-expander)*"
      },
      "pca9685": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The PCA9685 component represents a PCA9685 12-bit PWM driver ([datasheet](https://www.nxp.com/docs/en/data-sheet/PCA9685.pdf), [adafruit](https://www.adafruit.com/product/815)) in ESPHome. It uses [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) for communication.\n\n*See also: [pca9685 Component/Hub](https://esphome.io/components/output/pca9685.html#component-hub)*"
      },
      "pcf8574": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The PCF8574 component allows you to use PCF8574 or PCF8575 I/O expanders ([datasheet](http://www.ti.com/lit/ds/symlink/pcf8574.pdf), [SparkFun](https://www.sparkfun.com/products/retired/8130)) in ESPHome. It uses [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) for communication.\n\n*See also: [PCF8574 I/O Expander](https://esphome.io/components/pcf8574.html#pcf8574-i-o-expander)*"
      },
      "pipsolar": {
        "dependencies": [
          "uart"
        ],
        "docs": "The PipSolar component allows you to integrate PIP-compatible Inverters in ESPHome. It uses [UART](https://esphome.io/components/uart.html#uart) for communication.\n\n*See also: [PipSolar PV Inverter](https://esphome.io/components/pipsolar.html#pipsolar-pv-inverter)*"
      },
      "pn532": {},
      "pn532_i2c": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The `pn532` component allows you to use PN532 NFC/RFID controllers ([datasheet](https://cdn-shop.adafruit.com/datasheets/pn532ds.pdf), [Adafruit](https://www.adafruit.com/product/364)) with ESPHome. This component is a global hub that establishes the connection to the PN532 via [I\u00b2C](https://esphome.io/components/i2c.html#i2c) and outputs its data. Using the [PN532 binary sensors](https://esphome.io/components/binary_sensor/pn532.html#pn532-tag) you can then create individual binary sensors that track if an NFC/RFID tag is currently detected by the PN532.\n\n*See also: [pn532 Over I\u00b2C](https://esphome.io/components/binary_sensor/pn532.html#over-i2c)*"
      },
      "pn532_spi": {
        "dependencies": [
          "spi"
        ],
        "docs": "The `pn532_spi` component allows you to use PN532 NFC/RFID controllers ([datasheet](https://cdn-shop.adafruit.com/datasheets/pn532ds.pdf), [Adafruit](https://www.adafruit.com/product/364)) with ESPHome. This component is a global hub that establishes the connection to the PN532 via [SPI](https://esphome.io/components/spi.html#spi) and outputs its data. Using the [PN532 binary sensors](https://esphome.io/components/binary_sensor/pn532.html#pn532-tag) you can then create individual binary sensors that track if an NFC/RFID tag is currently detected by the PN532.\n\n*See also: [pn532 Over SPI](https://esphome.io/components/binary_sensor/pn532.html#over-spi)*"
      },
      "pn7150_i2c": {
        "dependencies": [
          "i2c"
        ]
      },
      "pn7160_i2c": {
        "dependencies": [
          "i2c"
        ]
      },
      "pn7160_spi": {
        "dependencies": [
          "spi"
        ]
      },
      "power_supply": {
        "docs": "The `power_supply` component allows you to have a high power mode for certain outputs. For example, if you\u2019re using an [ATX power supply](https://en.wikipedia.org/wiki/ATX) to power your LED strips, you usually don\u2019t want to have the power supply on all the time while the output is not on. The power supply component can be attached to any [Output Component](https://esphome.io/components/output/index.html#output) and will automatically switch on if any of the outputs are on. Furthermore, it also has a cooldown time that keeps the power supply on for a while after the last output has been disabled.\n\n*See also: [Power Supply Component](https://esphome.io/components/power_supply.html#power-supply-component)*"
      },
      "preferences": {},
      "prometheus": {
        "docs": "The `prometheus` component enables an HTTP endpoint for the [Web Server Component](https://esphome.io/components/web_server.html) in order to integrate a [Prometheus](https://prometheus.io/) installation.\n\n*See also: [Prometheus Component](https://esphome.io/components/prometheus.html#prometheus-component)*"
      },
      "psram": {
        "dependencies": [
          "esp32"
        ],
        "docs": "This component enables and configures PSRAM if/when available on ESP32 modules/boards. It is automatically loaded and enabled by components that require it.\n\n*See also: [PSRAM](https://esphome.io/components/psram.html#psram)*"
      },
      "pylontech": {
        "dependencies": [
          "uart"
        ],
        "docs": "**[ID](https://esphome.io/guides/configuration-types.html#config-id)**: The id to use for this Pylontech component.\n\n*See also: [pylontech Component/Hub](https://esphome.io/components/pylontech.html#component-hub)*"
      },
      "qr_code": {
        "dependencies": [
          "display"
        ],
        "docs": "Use this component to generate a QR-code containing a string on the device, which can then be drawn on compatible displays.\n\n*See also: [QR Code Component](https://esphome.io/components/qr_code.html#qr-code-component)*"
      },
      "radon_eye_ble": {
        "dependencies": [
          "esp32_ble_tracker"
        ]
      },
      "rc522_i2c": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The `rc522_i2c` component allows you to use RC522 NFC/RFID controllers with ESPHome. This component is a global hub that establishes the connection to the RC522 via [I\u00b2C](https://esphome.io/components/i2c.html#i2c) (also available over SPI). Using the [RC522 binary sensors](https://esphome.io/components/binary_sensor/rc522.html#rc522-binary-sensor) you can then create individual binary sensors that track if an NFC/RFID tag is currently detected by the RC522.\n\n*See also: [rc522 Over I\u00b2C](https://esphome.io/components/binary_sensor/rc522.html#over-i2c)*"
      },
      "rc522_spi": {
        "dependencies": [
          "spi"
        ],
        "docs": "The `rc522_spi` component allows you to use RC522 NFC/RFID controllers with ESPHome. This component is a global hub that establishes the connection to the RC522 via [SPI](https://esphome.io/components/spi.html#spi). Using [RC522 binary sensors](https://esphome.io/components/binary_sensor/rc522.html#rc522-binary-sensor), you can then create individual binary sensors that track if an NFC/RFID tag is currently detected by the RC522.\n\n*See also: [rc522 Over SPI](https://esphome.io/components/binary_sensor/rc522.html#over-spi)*"
      },
      "rdm6300": {
        "dependencies": [
          "uart"
        ],
        "docs": "The `rdm6300` component allows you to use RDM6300 NFC/RFID controllers ([datasheet](https://elty.pl/upload/download/RFID/RDM630-Spec.pdf), [iTead](https://www.itead.cc/rdm6300.html)) with ESPHome. This component is a global hub that establishes the connection to the RDM6300 via [UART](https://esphome.io/components/uart.html#uart) and translates the received data. Using the [RDM6300 binary sensors](https://esphome.io/components/binary_sensor/rdm6300.html#rdm6300-tag) you can then create individual binary sensors that track if an NFC/RFID tag is currently detected by the RDM6300.\n\n*See also: [rdm6300 Component/Hub](https://esphome.io/components/binary_sensor/rdm6300.html#component-hub)*"
      },
      "remote_receiver": {
        "docs": "The `remote_receiver` component lets you receive and decode various common remote control signals, such as infrared or 433 MHz radio frequency (RF) signals.\n\n*See also: [Remote Receiver](https://esphome.io/components/remote_receiver.html#remote-receiver)*"
      },
      "remote_transmitter": {
        "docs": "The `remote_transmitter` component lets you send various common remote control signals, such as infrared or 433 MHz radio frequency (RF) signals.\n\n*See also: [Remote Transmitter](https://esphome.io/components/remote_transmitter.html#remote-transmitter)*"
      },
      "rf_bridge": {
        "dependencies": [
          "uart"
        ],
        "docs": "The `RF Bridge` Component provides the ability to send and receive 433MHz remote codes using the embedded EFM8BB1 microcontroller. This component implements the communication protocol that the original `efm8bb1` firmware implements. The device is connected via the [UART bus](https://esphome.io/components/uart.html). The uart bus must be configured at the same speed of the module which is 19200bps.\n\n*See also: [RF Bridge Component](https://esphome.io/components/rf_bridge.html#rf-bridge-component)*"
      },
      "rp2040": {
        "docs": "This component contains platform-specific options for the RP2040 platform.\n\n*See also: [RP2040 Platform](https://esphome.io/components/rp2040.html#rp2040-platform)*"
      },
      "rtl87xx": {},
      "rtttl": {
        "docs": "The `rtttl`, component allows you to easily connect a passive piezo buzzer to your microcontroller and play monophonic songs. It accepts the Ring Tone Text Transfer Language, rtttl format ([Wikipedia](https://en.wikipedia.org/wiki/Ring_Tone_Transfer_Language)) which allows to store simple melodies.\n\n*See also: [Rtttl Buzzer](https://esphome.io/components/rtttl.html#rtttl-buzzer)*"
      },
      "ruuvi_ble": {
        "dependencies": [
          "esp32_ble_tracker"
        ]
      },
      "safe_mode": {
        "docs": "Sometimes hardware and/or software doesn\u2019t behave as expected. ESPHome supports a \u201csafe mode\u201d to help recover from repeated boot failures/reboot loops. After a specified number (the default is ten) of boot failures, the safe mode may be invoked; in this mode, all components are disabled except serial logging, network (Wi-Fi or Ethernet) and the OTA component(s). In most cases, this will temporarily mitigate the issue, allowing you a chance to correct it, perhaps by uploading a new binary.\n\n*See also: [Safe Mode](https://esphome.io/components/safe_mode.html#safe-mode)*"
      },
      "script": {
        "docs": "ESPHome\u2019s `script` component allows you to define a list of steps (actions) in a central place. You can then execute the script from nearly anywhere in your device\u2019s configuration with a single call.\n\n*See also: [Script Component](https://esphome.io/components/script.html#script-component)*"
      },
      "seeed_mr24hpc1": {
        "dependencies": [
          "uart"
        ],
        "docs": "The `seeed_mr24hpc1` platform allows you to use Seeed Studio 24GHz mmWave Sensor - Human Static Presence Module Lite ([Product Page](https://www.seeedstudio.com/24GHz-mmWave-Sensor-Human-Static-Presence-Module-Lite-p-5524.html)) and Seeed Studio mmWave Human Detection Sensor Kit ([Product Page](https://www.seeedstudio.com/mmWave-Human-Detection-Sensor-Kit-p-5773.html)) with ESPHome.\n\n*See also: [seeed_mr24hpc1 Component/Hub](https://esphome.io/components/seeed_mr24hpc1.html#component-hub)*"
      },
      "seeed_mr60bha2": {
        "dependencies": [
          "uart"
        ],
        "docs": "The `seeed_mr60bha2` platform allows you to use Seeed Studio MR60BHA2 60GHz mmWave Fall Detection Sensor Kit with XIAO ESP32C6 ([Product Page](https://www.seeedstudio.com/MR60BHA2-60GHz-mmWave-Sensor-Breathing-and-Heartbeat-Module-p-5945.html)) with ESPHome.\n\n*See also: [seeed_mr60bha2 Component/Hub](https://esphome.io/components/seeed_mr60bha2.html#component-hub)*"
      },
      "seeed_mr60fda2": {
        "dependencies": [
          "uart"
        ],
        "docs": "The `seeed_mr60fda2` platform allows you to use Seeed Studio\u2019s MR60FDA2 60GHz mmWave Fall Detection Sensor Kit with XIAO ESP32C6 ([Product Page](https://www.seeedstudio.com/MR60FDA2-60GHz-mmWave-Sensor-Fall-Detection-Module-p-5946.html)) with ESPHome.\n\n*See also: [seeed_mr60fda2 Component/Hub](https://esphome.io/components/seeed_mr60fda2.html#component-hub)*"
      },
      "servo": {
        "docs": "The `servo` component allows you to use servo motors with ESPHome. Servos are motor controllers that contain all the electronics necessary for driving the motor and provide a simple PWM interface to control the motor.\n\n*See also: [Servo Component](https://esphome.io/components/servo.html#servo-component)*"
      },
      "sim800l": {
        "dependencies": [
          "uart"
        ],
        "docs": "The `SIM800L` Component provides the ability to dial, answer calls, send/receive SMS text messages and send/receive USSD codes. The device must be connected via a [UART bus](https://esphome.io/components/uart.html) supporting both receiving and transmitting line. The UART bus must be configured at the same speed of the module which is by default 9600bps. The required connection wires are `+VCC`, `GND`, `RX` and `TX`.\n\n*See also: [sim800l Component/Hub](https://esphome.io/components/sim800l.html#component-hub)*"
      },
      "sm16716": {
        "docs": "The SM16716 component represents a SM16716 LED driver chain ([SM16716 description](https://github.com/sowbug/sm16716/blob/master/SM16716%20Datasheet%20%5BChinese%5D.pdf), [SM16716 description](https://github.com/sowbug/sm16716/blob/master/SM16716%20Datasheet%20%5BChinese%5D.pdf)) in ESPHome. Communication is done with two GPIO pins (MOSI and SCLK) and multiple driver chips can be chained. It is used in some smart light bulbs:\n\n*See also: [sm16716 Component/Hub](https://esphome.io/components/output/sm16716.html#component-hub)*"
      },
      "sm2135": {
        "docs": "The SM2135 component represents a SM2135 LED driver chain ([SM2135 description](https://github.com/arendst/Sonoff-Tasmota/files/3656603/SM2135E_zh-CN_en-US_translated.pdf), [SM2135 description](https://github.com/arendst/Sonoff-Tasmota/files/3656603/SM2135E_zh-CN_en-US_translated.pdf)) in ESPHome. Communication is done with two GPIO pins (MOSI and SCLK). It is used in some smart light bulbs:\n\n*See also: [sm2135 Component/Hub](https://esphome.io/components/output/sm2135.html#component-hub)*"
      },
      "sm2235": {
        "docs": "The SM2235 component represents a SM2235 LED driver chain in ESPHome. Communication is done with two GPIO pins (DATA and CLK).\n\n*See also: [sm2235 Component/Hub](https://esphome.io/components/output/sm2235.html#component-hub)*"
      },
      "sm2335": {
        "docs": "The SM2335 component represents a SM2335 LED driver chain in ESPHome. Communication is done with two GPIO pins (DATA and CLK). It is used in some smart light bulbs:\n\n*See also: [sm2335 Component/Hub](https://esphome.io/components/output/sm2335.html#component-hub)*"
      },
      "sml": {
        "dependencies": [
          "uart"
        ],
        "docs": "As the communciation with the sensor is done using UART, you need to have the [UART bus](https://esphome.io/components/uart.html#uart) in your configuration. The interface parameters should be set to 9600/8N1 or 9600/7E1 depending on your smart meter. If you see checksum errors in the log try changing the interface parameter.\n\n*See also: [sml Component/Hub](https://esphome.io/components/sml.html#component-hub)*"
      },
      "sn74hc165": {
        "docs": "The SN74HC165 component allows you to use SN74HC165 shift registers as I/O expanders (Input only, use SN74HC595 for outputs) ([datasheet](https://www.ti.com/lit/ds/symlink/sn74hc165.pdf)) in ESPHome. It uses 3 wires (optionally 4) for communication.\n\n*See also: [SN74HC165 I/O Expander (shift register)](https://esphome.io/components/sn74hc165.html#sn74hc165-i-o-expander-shift-register)*"
      },
      "sn74hc595": {
        "docs": "The SN74HC595 component allows you to use SN74HC595 shift registers as I/O expanders ([datasheet](http://www.ti.com/lit/ds/symlink/sn74hc595.pdf), [SparkFun](https://www.sparkfun.com/products/13699)) in ESPHome. It uses 3 wires (optionally 4) for communication. Optionally, it can be added to a SPI bus to allow sharing pins with other components.\n\n*See also: [SN74HC595 I/O Expander (shift register)](https://esphome.io/components/sn74hc595.html#sn74hc595-i-o-expander-shift-register)*"
      },
      "socket": {},
      "spi": {
        "docs": "SPI is a very common high-speed protocol for a lot of devices. The ESPHome SPI component implements only the host controller role, where it controls the bus, and writes or reads data from peripherals attached to the bus.\n\n*See also: [SPI Bus](https://esphome.io/components/spi.html#spi-bus)*"
      },
      "spi_device": {
        "dependencies": [
          "spi"
        ],
        "docs": "Other components that depend on the SPI component will reference it, typically to communicate with specific peripheral devices. There is also a general-purpose SPI device component that can be used to communicate with hardware not supported by a specific component. It allows selection of the SPI mode, data_rate, CS pin and bit order. Reads and writes on the device can be performed with lambdas. For example:\n\n*See also: [Generic SPI device component:](https://esphome.io/components/spi.html#generic-spi-device-component)*"
      },
      "sprinkler": {
        "docs": "The `sprinkler` controller component aims to behave like a sprinkler/irrigation valve controller, much like those made by companies such as Rain Bird or Hunter. It does so by automating control of a number of [switch](https://esphome.io/components/switch/index.html#config-switch) components, each of which would typically be used to control an individual electric valve via a relay or other switching device. It provides a number of features you\u2019d expect of a sprinkler controller, including:\n\n*See also: [Sprinkler Controller](https://esphome.io/components/sprinkler.html#sprinkler-controller)*"
      },
      "statsd": {
        "dependencies": [
          "network"
        ],
        "docs": "StatsD is a [protocol](https://github.com/statsd/statsd/blob/master/docs/metric_types.md) to send metrics to a Daemon to store and aggregate them. Today there are many monitoring solutions that support receiving metrics via the StatsD protocol.\n\n*See also: [StatsD](https://esphome.io/components/statsd.html#statsd)*"
      },
      "status_led": {
        "docs": "The `status_led` hooks into all ESPHome components and can indicate the status of the device. Specifically, it will:\n\n*See also: [Status LED](https://esphome.io/components/status_led.html#status-led)*"
      },
      "substitutions": {
        "docs": "ESPHome has a powerful way to reduce repetition in configuration files: substitutions. With substitutions, you can have a single generic source file for all nodes of one kind and substitute expressions in as required.\n\n*See also: [Substitutions](https://esphome.io/components/substitutions.html#substitutions)*"
      },
      "sun": {
        "docs": "The `sun` component allows you to track the sun\u2019s position in the sky. Calculations are done every 60 seconds.\n\n*See also: [Sun](https://esphome.io/components/sun.html#sun)*"
      },
      "sun_gtil2": {
        "dependencies": [
          "uart"
        ],
        "docs": "**[ID](https://esphome.io/guides/configuration-types.html#config-id)**: The id to use for this component.\n\n*See also: [sun_gtil2 Component/Hub](https://esphome.io/components/sun_gtil2.html#component-hub)*"
      },
      "sx1509": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The SX1509 component allows you to expand your I/O capabilities: ([datasheet](https://www.semtech.com/uploads/documents/sx1509_evk_users_guide.pdf), [SparkFun](https://learn.sparkfun.com/tutorials/sx1509-io-expander-breakout-hookup-guide/all)) in ESPHome. It uses [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) for communication.\n\n*See also: [SX1509 16 channel I/O Expander with LED driver and keypad engine](https://esphome.io/components/sx1509.html#sx1509-16-channel-i-o-expander-with-led-driver-and-keypad-engine)*"
      },
      "tca9548a": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The TCA9548A component allows you to use TCA9548A as a I\u00b2C multiplexer ([datasheet](https://www.ti.com/lit/ds/symlink/tca9548a.pdf), [AdaFruit](https://learn.adafruit.com/adafruit-tca9548a-1-to-8-i2c-multiplexer-breakout)) in ESPHome. It uses [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) for communication.\n\n*See also: [TCA9548A I\u00b2C Multiplexer](https://esphome.io/components/tca9548a.html#tca9548a-i2c-multiplexer)*"
      },
      "tca9555": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The TCA9555 component allows you to use TCA955 I/O expanders ([datasheet](https://www.ti.com/lit/ds/symlink/tca9555.pdf)) in ESPHome. It uses [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) for communication.\n\n*See also: [TCA9555 I/O Expander](https://esphome.io/components/tca9555.html#tca9555-i-o-expander)*"
      },
      "teleinfo": {
        "docs": "The `teleinfo` component allows you to retrieve data from a French electrical counter using Teleinformation ([datasheet](https://www.enedis.fr/media/2035/download)). It works with Linky electrical counter but also legacy EDF electrical counter.\n\n*See also: [teleinfo Component/Hub](https://esphome.io/components/sensor/teleinfo.html#component-hub)*"
      },
      "tlc59208f": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The TLC59208F component represents a Texas Instruments TLC59208F 8-bit PWM driver ([datasheet](http://www.ti.com/lit/gpn/tlc59208f), [hw example](https://faboplatform.github.io/ArduinoDocs/03.I2C%20Brick/211_brick_i2c_7seg/)) in ESPHome. It uses [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) for communication.\n\n*See also: [tlc59208f Component/Hub](https://esphome.io/components/output/tlc59208f.html#component-hub)*"
      },
      "tlc5947": {
        "docs": "This component represents a chain of [TLC5947 24-Channel, 12-Bit PWM LED Drivers](https://www.ti.com/lit/ds/symlink/tlc5947.pdf), which is used e.g. on this [board from Adafruit](https://www.adafruit.com/product/1429).\n\n*See also: [tlc5947 Component/Hub](https://esphome.io/components/output/tlc5947.html#component-hub)*"
      },
      "tlc5971": {
        "docs": "This component represents a chain of [TLC5971 12-Channel, 16-Bit PWM LED Drivers](https://www.ti.com/lit/ds/symlink/tlc5971.pdf), which is used e.g. on this [board from Adafruit](https://www.adafruit.com/product/1455).\n\n*See also: [tlc5971 Component/Hub](https://esphome.io/components/output/tlc5971.html#component-hub)*"
      },
      "tm1651": {
        "docs": "The `tm1651` display platform allows you to use battery display units based on the TM1651 chip such as [this one](https://www.aliexpress.com/item/32811491559.html) with ESPHome. This component supports the level and brightness settings. All updates can be made via lambda expressions.\n\n*See also: [TM1651 Battery Display](https://esphome.io/components/tm1651.html#tm1651-battery-display)*"
      },
      "ttp229_bsf": {
        "docs": "The configuration is made up of two parts: The central component, and individual Binary sensors per channel.\n\n*See also: [ttp229_bsf Component](https://esphome.io/components/binary_sensor/ttp229.html#ttp229-bsf-component)*"
      },
      "ttp229_lsf": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The configuration is made up of two parts: The central component, and individual Binary sensors per channel.\n\n*See also: [ttp229_lsf Component](https://esphome.io/components/binary_sensor/ttp229.html#ttp229-lsf-component)*"
      },
      "tuya": {
        "dependencies": [
          "uart"
        ],
        "docs": "The `tuya` component creates a serial connection to the Tuya MCU for platforms to use.\n\n*See also: [Tuya MCU](https://esphome.io/components/tuya.html#tuya-mcu)*"
      },
      "uart": {
        "docs": "UART is a common serial protocol for a lot of devices. For example, when uploading a binary to your ESP you have probably used UART to access the chip. UART (or for Arduino often also called Serial) usually consists of 2 pins:\n\n*See also: [UART Bus](https://esphome.io/components/uart.html#uart-bus)*"
      },
      "udp": {
        "dependencies": [
          "network"
        ],
        "docs": "The purpose of this component is to allow ESPHome nodes to directly communicate with each over an IP network. It permits the state of sensors and binary sensors to be broadcast via UDP packets to other nodes on the same LAN, or to specific IP addresses (which may be in remote, but reachable networks).\n\n*See also: [UDP Component](https://esphome.io/components/udp.html#udp-component)*"
      },
      "uponor_smatrix": {
        "dependencies": [
          "uart"
        ],
        "docs": "The Uponor Smatrix component allows you to integrate an Uponor Smatrix Base Pulse underfloor heating control system in ESPHome without the need for an Smatrix Pulse Com R-208 communication module. It directly communicates with the controller and thermostats via the RS485 thermostat bus.\n\n*See also: [Uponor Smatrix Base Pulse Underfloor Heating](https://esphome.io/components/uponor_smatrix.html#uponor-smatrix-base-pulse-underfloor-heating)*"
      },
      "vbus": {
        "dependencies": [
          "uart"
        ],
        "docs": "The `VBus` Component provides status reading connectivity to solar heat energy collector controllers using VBus protocol. These devices are mainly produced by Resol, often also found under different brand names like Viessmann, Kioto, Wagner etc. The component currently supports natively the models in the table below but any device can be added via lambda by knowing [its packet structure](https://danielwippermann.github.io/resol-vbus).\n\n*See also: [VBus Component](https://esphome.io/components/vbus.html#vbus-component)*"
      },
      "voice_assistant": {
        "dependencies": [
          "api",
          "microphone"
        ],
        "docs": "ESPHome devices with a microphone are able to stream the audio to Home Assistant and be processed there by [assist](https://www.home-assistant.io/voice_control/).\n\n*See also: [Voice Assistant](https://esphome.io/components/voice_assistant.html#voice-assistant)*"
      },
      "web_server": {
        "docs": "The `web_server` component creates a simple web server on the node that can be accessed through any browser and a simple [REST API](https://esphome.io/web-api/index.html#api-rest). Please note that enabling this component will take up *a lot* of memory and may decrease stability, especially on ESP8266.\n\n*See also: [Web Server Component](https://esphome.io/components/web_server.html#web-server-component)*"
      },
      "web_server_base": {
        "dependencies": [
          "network"
        ]
      },
      "web_server_idf": {},
      "wiegand": {
        "docs": "The `wiegand` component allows you to integrate Wiegand-standard key input and card or tag reader panels in Home Assistant.\n\n*See also: [Wiegand keypad and tag reader](https://esphome.io/components/wiegand.html#wiegand-keypad-and-tag-reader)*"
      },
      "wifi": {
        "docs": "WPA2_EAP Enterprise Authentication is supported on ESP32s and ESP8266s. In order to configure this feature you must use the [Connecting to Multiple Networks](https://esphome.io/components/wifi.html#wifi-networks) style configuration. The ESP32 is known to work with PEAP, EAP-TTLS, and the certificate based EAP-TLS. These are advanced settings and you will usually need to consult your enterprise network administrator.\n\n*See also: [Enterprise Authentication](https://esphome.io/components/wifi.html#enterprise-authentication)*"
      },
      "wireguard": {
        "dependencies": [
          "time"
        ],
        "docs": "[WireGuard\u00ae](https://www.wireguard.org/) is an extremely simple yet fast and modern VPN that utilizes state-of-the-art cryptography. This component uses a **custom** implementation not developed by original authors and currently available for ESP32, ESP8266 and BK72xx microcontrollers *only*.\n\n*See also: [WireGuard Component](https://esphome.io/components/wireguard.html#wireguard-component)*"
      },
      "wk2132_i2c": {
        "dependencies": [
          "i2c"
        ]
      },
      "wk2132_spi": {
        "dependencies": [
          "spi"
        ]
      },
      "wk2168_i2c": {
        "dependencies": [
          "i2c"
        ]
      },
      "wk2168_spi": {
        "dependencies": [
          "spi"
        ]
      },
      "wk2204_i2c": {
        "dependencies": [
          "i2c"
        ]
      },
      "wk2204_spi": {
        "dependencies": [
          "spi"
        ]
      },
      "wk2212_i2c": {
        "dependencies": [
          "i2c"
        ]
      },
      "wk2212_spi": {
        "dependencies": [
          "spi"
        ]
      },
      "wled": {},
      "xiaomi_ble": {
        "dependencies": [
          "esp32_ble_tracker"
        ]
      },
      "xiaomi_rtcgq02lm": {
        "dependencies": [
          "esp32_ble_tracker"
        ]
      },
      "xl9535": {
        "dependencies": [
          "i2c"
        ],
        "docs": "The XL9535 component allows you to use **XL9535** I/O expander in ESPHome. It uses [I\u00b2C Bus](https://esphome.io/components/i2c.html#i2c) for communication.\n\n*See also: [XL9535 I/O Expander](https://esphome.io/components/xl9535.html#xl9535-i-o-expander)*"
      },
      "xpt2046": {}
    },
    "action": {
      "delay": {
        "templatable": true,
        "type": "schema",
        "schema": {
          "extends": [
            "core.positive_time_period_milliseconds"
          ]
        }
      },
      "if": {
        "type": "schema",
        "schema": {
          "config_vars": {
            "condition": {
              "key": "Optional",
              "type": "registry",
              "registry": "condition"
            },
            "any": {
              "key": "Optional"
            },
            "all": {
              "key": "Optional",
              "type": "registry",
              "registry": "condition"
            },
            "then": {
              "key": "Optional",
              "is_list": true,
              "type": "registry",
              "registry": "action"
            },
            "else": {
              "key": "Optional",
              "is_list": true,
              "type": "registry",
              "registry": "action"
            }
          }
        }
      },
      "while": {
        "type": "schema",
        "schema": {
          "config_vars": {
            "condition": {
              "key": "Required",
              "type": "registry",
              "registry": "condition"
            },
            "then": {
              "key": "Required",
              "is_list": true,
              "type": "registry",
              "registry": "action"
            }
          }
        }
      },
      "repeat": {
        "type": "schema",
        "schema": {
          "config_vars": {
            "count": {
              "key": "Required",
              "templatable": true,
              "type": "integer",
              "data_type": "positive_not_null_int"
            },
            "then": {
              "key": "Required",
              "is_list": true,
              "type": "registry",
              "registry": "action"
            }
          }
        }
      },
      "wait_until": {
        "type": "schema",
        "maybe": "condition",
        "schema": {
          "config_vars": {
            "condition": {
              "key": "Required",
              "type": "registry",
              "registry": "condition"
            },
            "timeout": {
              "key": "Optional",
              "templatable": true,
              "type": "schema",
              "schema": {
                "extends": [
                  "core.positive_time_period_milliseconds"
                ]
              }
            }
          }
        }
      },
      "lambda": {}
    },
    "condition": {
      "and": {
        "is_list": true,
        "type": "registry",
        "registry": "condition"
      },
      "or": {
        "is_list": true,
        "type": "registry",
        "registry": "condition"
      },
      "all": {
        "is_list": true,
        "type": "registry",
        "registry": "condition"
      },
      "any": {
        "is_list": true,
        "type": "registry",
        "registry": "condition"
      },
      "not": {
        "type": "registry",
        "registry": "condition"
      },
      "xor": {
        "is_list": true,
        "type": "registry",
        "registry": "condition"
      },
      "lambda": {},
      "for": {
        "type": "schema",
        "schema": {
          "config_vars": {
            "time": {
              "key": "Required",
              "templatable": true,
              "type": "schema",
              "schema": {
                "extends": [
                  "core.positive_time_period_milliseconds"
                ]
              }
            },
            "condition": {
              "key": "Required",
              "type": "registry",
              "registry": "condition"
            }
          },
          "extends": [
            "core.COMPONENT_SCHEMA"
          ]
        }
      }
    },
    "pins": [
      "esp32",
      "esp8266",
      "bk72xx",
      "ch422g",
      "host",
      "max6956",
      "mcp23xxx",
      "mcp23016",
      "mpr121",
      "pca6416a",
      "pca9554",
      "pcf8574",
      "rp2040",
      "rtl87xx",
      "sn74hc165",
      "sn74hc595",
      "sx1509",
      "tca9555",
      "wk2168_i2c",
      "wk2168_spi",
      "wk2212_i2c",
      "wk2212_spi",
      "xl9535"
    ]
  }
}